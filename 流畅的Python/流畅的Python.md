## 流程的python 第一版
- [流程的python 第一版](#流程的python-第一版)
	- [第一章 Python数据模型](#第一章-python数据模型)
		- [特殊方法](#特殊方法)
		- [自定义的布尔值](#自定义的布尔值)
	- [第二章 序列构成的数组](#第二章-序列构成的数组)
		- [内置序列类型概](#内置序列类型概)
		- [列表推导不会有变量泄漏的问题](#列表推导不会有变量泄漏的问题)
		- [嵌套元组拆包](#嵌套元组拆包)
		- [序列的增量赋值](#序列的增量赋值)
		- [list.sort方法和内置函数sorted](#listsort方法和内置函数sorted)
		- [内存视图](#内存视图)
		- [双向队列和其他形式的队](#双向队列和其他形式的队)
	- [第三章 字典和集合](#第三章-字典和集合)
		- [泛映射类型](#泛映射类型)
		- [什么是可散列的数据类型](#什么是可散列的数据类型)
		- [特殊方法__missing__](#特殊方法__missing__)
		- [字典的变种](#字典的变种)
		- [不可变映射类型](#不可变映射类型)
		- [集合的操作](#集合的操作)
		- [dict的实现及其导致的结果](#dict的实现及其导致的结果)
	- [第四章 文本和字节序列](#第四章-文本和字节序列)
	- [第五章 一等函数](#第五章-一等函数)
		- [高阶函数](#高阶函数)
		- [匿名函数](#匿名函数)
		- [可调用对象](#可调用对象)
		- [函数内省](#函数内省)
		- [仅限关键字参数](#仅限关键字参数)
		- [获取关于参数的信息](#获取关于参数的信息)
		- [使用 inspect 模块](#使用-inspect-模块)
		- [operator模块](#operator模块)
		- [使用functools.partial冻结参数](#使用functoolspartial冻结参数)
	- [第六章 使用一等函数实现设计模式](#第六章-使用一等函数实现设计模式)
	- [第七章 函数装饰器和闭包](#第七章-函数装饰器和闭包)
		- [变量作用域规则](#变量作用域规则)
		- [闭包](#闭包)
		- [nonlocal声明](#nonlocal声明)
		- [标准库中的装饰器](#标准库中的装饰器)
	- [第八章 对象引用、可变性和垃圾回收](#第八章-对象引用可变性和垃圾回收)
		- [变量不是盒子](#变量不是盒子)
		- [标识、相等性和别名](#标识相等性和别名)
		- [在\=\=和is之间选择](#在和is之间选择)
		- [元组的相对不可变性](#元组的相对不可变性)
		- [默认做浅复制](#默认做浅复制)
		- [为任意对象做深复制和浅复制](#为任意对象做深复制和浅复制)
		- [函数的参数作为引用时](#函数的参数作为引用时)
		- [不要使用可变类型作为参数的默认值](#不要使用可变类型作为参数的默认值)
		- [防御可变参数](#防御可变参数)
		- [del和垃圾回收](#del和垃圾回收)
		- [弱引用](#弱引用)
		- [弱引用的局限](#弱引用的局限)
		- [Python对不可变类型施加的把戏](#python对不可变类型施加的把戏)
		- [变量保存的是引用](#变量保存的是引用)
	- [第九章 符合Python风格的对象](#第九章-符合python风格的对象)
		- [classmethod与staticmethod](#classmethod与staticmethod)
		- [Python的私有属性和“受保护的”属性](#python的私有属性和受保护的属性)
		- [使用__slots__类属性节省空间](#使用__slots__类属性节省空间)
		- [\_\_slots__的问题](#__slots__的问题)
		- [覆盖类属性](#覆盖类属性)
	- [第十章 序列的修改、散列和切片](#第十章-序列的修改散列和切片)
		- [切片原理](#切片原理)
		- [动态存取属性](#动态存取属性)
		- [REDUCE和map](#reduce和map)
	- [第十一章 接口：从协议到抽象基类](#第十一章-接口从协议到抽象基类)
		- [接口](#接口)
		- [序列协议](#序列协议)
		- [猴子补丁](#猴子补丁)
		- [鸭子类型](#鸭子类型)
		- [定义抽象基类的子类](#定义抽象基类的子类)
		- [标准库中的抽象基类](#标准库中的抽象基类)
		- [抽象基类的数字塔](#抽象基类的数字塔)
		- [定义并使用一个抽象基类](#定义并使用一个抽象基类)
		- [异常类的部分层次结构](#异常类的部分层次结构)
		- [抽象基类句法详解](#抽象基类句法详解)
		- [使用 register 方法声明虚拟子类](#使用-register-方法声明虚拟子类)
		- [即便不注册，抽象基类也能把一个类识别为虚拟子类](#即便不注册抽象基类也能把一个类识别为虚拟子类)
	- [第十二章 继承的优缺点](#第十二章-继承的优缺点)
		- [子类化内置类型很麻烦](#子类化内置类型很麻烦)
		- [多重继承和方法解析顺序](#多重继承和方法解析顺序)
		- [处理多重继承](#处理多重继承)
	- [第十三章 正确重载运算符](#第十三章-正确重载运算符)
		- [运算符重载基础](#运算符重载基础)
		- [一元运算符](#一元运算符)
		- [中缀运算符](#中缀运算符)
		- [比较运算符](#比较运算符)
		- [增量赋值运算符](#增量赋值运算符)
	- [第十四章 可迭代的对象、迭代器和生成器](#第十四章-可迭代的对象迭代器和生成器)
		- [yield关键字](#yield关键字)
		- [iter函数](#iter函数)
		- [可迭代的对象与迭代器的对比](#可迭代的对象与迭代器的对比)
		- [迭代器](#迭代器)
		- [生成器函数](#生成器函数)
		- [生成器表达式](#生成器表达式)
		- [标准库中的生成器函数](#标准库中的生成器函数)
		- [yield from](#yield-from)
		- [可迭代的归约函数](#可迭代的归约函数)
		- [深入分析iter函数](#深入分析iter函数)
		- [把生成器当成协程](#把生成器当成协程)
	- [第十五章 上下文管理器和else块](#第十五章-上下文管理器和else块)
		- [if语句之外的else块](#if语句之外的else块)
		- [上下文管理器和with块](#上下文管理器和with块)
		- [contextlib模块中的实用工具](#contextlib模块中的实用工具)
		- [使用@contextmanager](#使用contextmanager)
	- [第十六章 协程](#第十六章-协程)
		- [生成器如何进化成协程](#生成器如何进化成协程)
		- [用作协程的生成器的基本行为](#用作协程的生成器的基本行为)
		- [使用协程计算移动平均值](#使用协程计算移动平均值)
		- [预激协程的装饰器](#预激协程的装饰器)
		- [终止协程和异常处理](#终止协程和异常处理)
		- [让协程返回值](#让协程返回值)
		- [使用yield from](#使用yield-from)
		- [yield from的意义](#yield-from的意义)
		- [协程](#协程)
	- [第十七章 使用future处理并发](#第十七章-使用future处理并发)
		- [使用concurrent.futures模块](#使用concurrentfutures模块)
		- [future 的概念](#future-的概念)
		- [阻塞型I/O和GIL](#阻塞型io和gil)
		- [使用concurrent.futures模块启动进程](#使用concurrentfutures模块启动进程)
	- [第十八章 使用asyncio包处理并发](#第十八章-使用asyncio包处理并发)
		- [asyncio](#asyncio)
		- [@asyncio.coroutine 装饰器](#asynciocoroutine-装饰器)
		- [TODO](#todo)
	- [第十九章 动态属性和特性](#第十九章-动态属性和特性)
		- [使用动态属性访问JSON类数据](#使用动态属性访问json类数据)
		- [使用__new__方法以灵活的方式创建对象](#使用__new__方法以灵活的方式创建对象)
		- [特性全解析](#特性全解析)
		- [特性会覆盖实例属性](#特性会覆盖实例属性)
		- [定义一个特性工厂函数](#定义一个特性工厂函数)
		- [影响属性处理方式的特殊属性](#影响属性处理方式的特殊属性)
		- [处理属性的内置函数](#处理属性的内置函数)
		- [处理属性的特殊方法](#处理属性的特殊方法)
	- [第二十章 属性描述符](#第二十章-属性描述符)
		- [描述符](#描述符)
		- [描述符示例：验证属性](#描述符示例验证属性)
		- [覆盖型与非覆盖型描述符对比](#覆盖型与非覆盖型描述符对比)
		- [方法是描述符](#方法是描述符)
		- [描述符用法建议](#描述符用法建议)
		- [描述符的文档字符串和覆盖删除操作](#描述符的文档字符串和覆盖删除操作)
	- [第二十一章 类元编程](#第二十一章-类元编程)
		- [类工厂函数](#类工厂函数)
		- [类装饰器](#类装饰器)
		- [导入时和运行时比较](#导入时和运行时比较)
		- [元类基础知识](#元类基础知识)
		- [定制描述符的元类](#定制描述符的元类)
		- [元类的特殊方法__prepare__](#元类的特殊方法__prepare__)
		- [类作为对象](#类作为对象)
### 第一章 Python数据模型
#### 特殊方法
- 如果是 Python 内置的类型，比如列表（list）、字符串（str）、字节序列（bytearray） 等，那么 CPython 会抄个近路，\_\_len\_\_ 实际上会直接返回 PyVarObject 里的 ob_size 属 性。PyVarObject 是表示内存中长度可变的内置对象的 C 语言结构体。直接读取这个值比 调用一个方法要快很多。

- 很多时候，特殊方法的调用是隐式的，比如 for i in x: 这个语句，背后其实用的是 iter(x)，而这个函数的背后则是 x.\_\_iter\_\_() 方法。

![](assets/Pasted%20image%2020220801223225.png)

#### 自定义的布尔值
- 默认情况下，我们自己定义的类的实例总被认为是真的，除非这个类对 \_\_bool\_\_ 或者 __ len__ 函数有自己的实现。bool(x) 的背后是调用 x.\_\_bool\_\_() 的结果；如果不存在 __ bool__ 方法，那么 bool(x) 会尝试调用 x.\_\_len\_\_()。

---
### 第二章 序列构成的数组
#### 内置序列类型概
- 容器序列： list、tuple 和 collections.deque 这些序列能存放不同类型的数据。 
- 扁平序列： str、bytes、bytearray、memoryview 和 array.array，这类序列只能容纳一种类型。

序列类型还能按照能否被修改来分类。 
- 可变序列 list、bytearray、array.array、collections.deque 和 memoryview。 
- 不可变序列 tuple、str 和 bytes。

 ![](assets/Pasted%20image%2020220801225850.png)
 
#### 列表推导不会有变量泄漏的问题
- 列表推导、生成器表达式，以及同它们很相似的集合（set）推导和字典（dict）推 导，在 Python 3 中都有了自己的局部作用域，就像函数似的。

#### 嵌套元组拆包 
接受表达式的元组可以是嵌套式的，例如 (a, b, (c, d))。

#### 序列的增量赋值
增量赋值 += 和 \*= 会区别对待可变和不可变序列。在遇到不可变序列时，这两个操作 会在背后生成新的序列。但如果被赋值的对象是可变的，那么这个序列会就地修改——然 而这也取决于序列本身对特殊方法的实现。

#### list.sort方法和内置函数sorted
list.sort 方法会就地排序列表，sorted会新建一个列表作为返回值

#### 内存视图
- memoryview 是一个内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切片。
- memoryview.cast 的概念跟数组模块类似，能用不同的方式读写同一块内存数据，而且内容 字节不会随意移动。memoryview.cast 会 把同一块内存里的内容打包成一个全新的 memoryview 对象给你。

#### 双向队列和其他形式的队
collections.deque 类（双向队列）是一个线程安全、可以快速从两端添加或者删除元素的 数据类型。

除了 deque 之外，还有些其他的 Python 标准库也有对队列的实现
![](assets/Pasted%20image%2020220801231614.png)

---
### 第三章 字典和集合
#### 泛映射类型
![](assets/Pasted%20image%2020220802083608.png)

#### 什么是可散列的数据类型
- 如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变 的，而且这个对象需要实现 \_\_hash\_\_() 方法。另外可散列对象还要有 \_\_eq\_\_() 方法，这样才能跟其他键做比较。如果两个可散列对象是相等的，那么它们的 散列值一定是一样的……
- 一般来讲用户自定义的类型的对象都是可散列的，散列值就是它们的 id() 函数的返 回值，所以所有这些对象在比较的时候都是不相等的。如果一个对象实现了 __eq__ 方 法，并且在方法中用到了这个对象的内部状态的话，那么只有当所有这些内部状态都 是不可变的情况下，这个对象才是可散列的。

#### 特殊方法__missing__
如果有一个类继承了 dict（或UserDict），然后这个继承类提供了 \_\_missing\_\_ 方 法，那么在 \_\_getitem\_\_ 碰到找不到的键的时候，Python 就会自动调用它，而不是抛出一个 KeyError 异常。

#### 字典的变种
![](assets/Pasted%20image%2020220802091547.png)
UserDict 并不是 dict 的子类，但是 UserDict 有一个叫作 data 的属性，是 dict 的实例，这个属性实际上是 UserDict 最终存储数据的地方。

#### 不可变映射类型
从 Python 3.3 开始，types 模块中引入了一个封装类名叫 MappingProxyType。如果给这个类 一个映射，它会返回一个只读的映射视图。虽然是个只读视图，但是它是动态的。这意味 着如果对原映射做出了改动，我们通过这个视图可以观察到，但是无法通过这个视图对原 映射做出修改。

#### 集合的操作
![](assets/Pasted%20image%2020220802093318.png)
![](assets/Pasted%20image%2020220802093404.png)
- 中缀表达式版本要求左右两边的操作数都是相同的集合类型，而函数版本只要求第一个操作数是集合类型。
![](assets/Pasted%20image%2020220802093542.png)

#### dict的实现及其导致的结果
- **键必须是可散列的**
 一个可散列的对象必须满足以下要求。 
 (1) 支持 hash() 函数，并且通过 \_\_hash__() 方法所得到的散列值是不变的。 
 (2) 支持通过 \_\_eq__() 方法来检测相等性。 
 (3) 若 a == b 为真，则 hash(a) == hash(b) 也为真。
 所有由用户自定义的对象默认都是可散列的，因为它们的散列值由 id() 来获取，而且它们 都是不相等的。
- **字典在内存上的开销巨大**
- **键查询很快**
- **键的次序取决于添加顺序**（python3.7的字典是有序的）
- **往字典里添加新键可能会改变已有键的顺序**（python3.7的字典是有序的）
在 Python 3 中，.keys()、.items() 和 .values() 方法返回的都是字典视图。

---
### 第四章 文本和字节序列
*略*

---
### 第五章 一等函数
#### 高阶函数
接受函数为参数，或者把函数作为结果返回的函数是高阶函数（higher-order function）。
#### 匿名函数
Python 简单的句法限制了 lambda 函数的定义体只能使用纯表达式。换句话说， lambda 函数的定义体中不能赋值，也不能使用 while 和 try 等 Python 语句。

#### 可调用对象
- 用户定义的函数：使用 def 语句或 lambda 表达式创建。
- 内置函数：使用 C 语言（CPython）实现的函数，如 len 或 time.strftime。
- 内置方法：使用 C 语言实现的方法，如 dict.get。
- 方法：在类的定义体中定义的函数。
- 类：调用类时会运行类的 \_\_new__ 方法创建一个实例，然后运行 \_\_init__ 方法，初始化实 例，最后把实例返回给调用方。因为 Python 没有 new 运算符，所以调用类相当于调用 函数。（通常，调用类会创建那个类的实例，不过覆盖 \_\_new__ 方法的话，也可能出现 其他行为)
- 类的实例：如果类定义了 \_\_call__ 方法，那么它的实例可以作为函数调用。
- 生成器函数：使用 yield 关键字的函数或方法。调用生成器函数返回的是生成器对象。

#### 函数内省
- 使用 dir 函数可以探知函数属性
- 与用户定义的常规类一样，函数使用 \_\_dict__ 属性存储赋予它的用户属性。这相当于一种 基本形式的注解。
![](assets/Pasted%20image%2020220802095958.png)

#### 仅限关键字参数
- Python 3 进一步提供了仅限关键字参数（keyword-only argument）。与之密切相关的是，调用函数时使用 * 和 \*\*“展 开”可迭代对象，映射到单个参数。
- 定义函数时若想指定仅限关键字参数，要把它们 放到前面有 * 的参数后面。如果不想支持数量不定的定位参数，但是想支持仅限关键字参 数，在签名中放一个 * 。
- 注意，仅限关键字参数不一定要有默认值，可以强制必须传入实参。

#### 获取关于参数的信息
- 函数对象有个 \_\_defaults__ 属性，它的值是一个元组，里面保存着定位参数和关键字参 数的默认值。仅限关键字参数的默认值在 \_\_kwdefaults__ 属性中。然而，参数的名称在 \_\_code__ 属性中，它的值是一个 code 对象引用，自身也有很多属性。
- 参数名称在 \_\_code__.co_varnames 中，不过里面还有函数定义体中创建的局部变量。因此，参数名称是前 N 个字符串，N 的值由\_\_code__.co_argcount 确定。顺便说一下，这里不包含前缀为 * 或 ** 的变长参数。

#### 使用 inspect 模块
inspect.signature 函数返回一个 inspect.Signature 对象，它有一个 parameters 属性，这是一个有序映射，把参数名和 inspect.Parameter 对象对应起来。各个 Parameter 属性 也有自己的属性，例如 name、default 和 kind。特殊的 inspect.\_empty 值表示没有默认值
kind 属性的值是 \_ParameterKind 类中的 5 个值之一：
- POSITIONAL_OR_KEYWORD：可以通过定位参数和关键字参数传入的形参（多数 Python 函数的参数属于此类）。 
- VAR_POSITIONAL 定位参数元组。 
- VAR_KEYWORD 关键字参数字典。 
- KEYWORD_ONLY 仅限关键字参数（Python 3 新增）。 
- POSITIONAL_ONLY 仅限定位参数；目前，Python 声明函数的句法不支持，但是有些使用 C 语言实现且不 接受关键字参数的函数（如 divmod）支持。 
除了 name、default 和 kind，inspect.Parameter 对象还有一个 annotation（注解）属性， 它的值通常是 inspect.\_empty，但是可能包含 Python 3 新的注解句法提供的函数签名元数据
inspect.Signature 对象有个 bind 方法，它可以把任意个参数绑定到签名中的形参上，所用的规则与实参到形参的匹配方式一样。框架可以使用这个方法在真正调用函数前验证参数。

#### operator模块
operator 模块中还有一类函数，能替代从序列中取出元素或读取对象属性的 lambda 表达 式：因此，itemgetter 和 attrgetter 其实会自行构建函数。
- itemgetter 使用 [] 运算符，因此它不仅支持序列，还支持映射和任何实现 \_\_getitem__ 方 法的类。
- attrgetter 与 itemgetter 作用类似，它创建的函数根据名称提取对象的属性。如果把 多个属性名传给 attrgetter，它也会返回提取的值构成的元组。此外，如果参数名中包 含 .（点号），attrgetter 会深入嵌套对象，获取指定的属性。
- methodcaller的作用与 attrgetter 和 itemgetter 类似，它会自行创建函数。methodcaller 创建的函数会在对象上调用参数指 定的方法。methodcaller 还可以冻结某些参数，也就是部分应用 （partial application），这与 functools.partial 函数的作用类似。

#### 使用functools.partial冻结参数
- functools.partial 这个高阶函数用于部分应用一个函数。部分应用是指，基于一个函数创 建一个新的可调用对象，把原函数的某些参数固定。
- functools.partialmethod 函数（Python 3.4 新增）的作用与 partial 一样，不过是用于处 理方法的。

---
### 第六章 使用一等函数实现设计模式
**略**

---
### 第七章 函数装饰器和闭包
#### 变量作用域规则
![](assets/Pasted%20image%2020220802173645.png)
如果在函数中赋值时想让解释器把 b 当成全局变量，要使用 global 声明

#### 闭包
- 闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的 非全局变量。函数是不是匿名的没有关系，关键是它能访问定义体之外定义的非全局变量。
![](assets/Pasted%20image%2020220802182246.png)
- 闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时， 虽然定义作用域不可用了，但是仍能使用那些绑定。 
- 注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量

#### nonlocal声明
Python 3 引入了 nonlocal 声明。它的作用是把变量标记为自由变量， 即使在函数中为变量赋予新值了，也会变成自由变量。如果为 nonlocal 声明的变量赋予新 值，闭包中保存的绑定会更新。

#### 标准库中的装饰器
Python 内置了三个用于装饰方法的函数：property、classmethod 和 staticmethod。
- functools.wraps 装饰器把相关的属性从 func 复制到 decorate 中
- functools.lru_cache 实现了备忘（memoization）功能。这是一 项优化技术，它把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。LRU 三 个字母是“Least Recently Used”的缩写，表明缓存不会无限制增长，一段时间不用的缓存 条目会被扔掉。maxsize 参数指定存储多少个调用的结果。缓存满了之后，旧的结果会被扔掉，腾出空间。 为了得到最佳性能，maxsize 应该设为 2 的幂。typed 参数如果设为 True，把不同参数类型 得到的结果分开保存，即把通常认为相等的浮点数和整数参数（如 1 和 1.0）区分开。顺 便说一下，因为 lru_cache 使用字典存储结果，而且键根据调用时传入的定位参数和关键 字参数创建，所以被 lru_cache 装饰的函数，它的所有参数都必须是可散列的。
- functools.singledispatch 装饰器可以把整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。使用 @singledispatch 装饰的普通函数会变成 泛函数（generic function）：根据第一个参数的类型，以不同方式执行相同操作的一组函数。
- singledispatch 机制的一个显著特征是，你可以在系统的任何地方和任何模块中注册专门函数。如果后来在新的模块中定义了新的类型，可以轻松地添加一个新的专门函数来处理那个类型。此外，你还可以为不是自己编写的或者不能修改的类添加自定义函数。

---
### 第八章 对象引用、可变性和垃圾回收
#### 变量不是盒子
- Python 变量类似于 Java 中的引用 式变量，因此最好把它们理解为附加在对象上的标注。对引用式变量来说，说把变量分配给对象 更合理，反过来说就有问题。
- 为了理解 Python 中的赋值语句，应该始终先读右边。对象在右边创建或获 取，在此之后左边的变量才会绑定到对象上，这就像为对象贴上标注。

#### 标识、相等性和别名
- 每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变；你可以把标识 理解为对象在内存中的地址。is 运算符比较两个对象的标识；id() 函数返回对象标 识的整数表示。
- 对象 ID 的真正意义在不同的实现中有所不同。在 CPython 中，id() 返回对象的内存地址， 但是在其他 Python 解释器中可能是别的值。关键是，ID 一定是唯一的数值标注，而且在 对象的生命周期中绝不会变。

#### 在\=\=和is之间选择
- == 运算符通常比较两个对象的值（对象中保存的数据），而 is 比较对象的标识。
- is 运算符比 == 速度快，因为它不能重载，所以 Python 不用寻找并调用特殊方法，而是直 接比较两个整数 ID。
- 而 a == b 是语法糖，等同于 a.\_\_eq__(b)。继承自 object 的 \_\_eq__ 方法比较两个对象的 ID，结果与 is 一样。但是多数内置类型使用更有意义的方式覆盖了 \_\_eq__ 方法，会考虑对象属性的值。

#### 元组的相对不可变性
- 元组与多数 Python 集合（列表、字典、集，等等）一样，保存的是对象的引用。如果引 用的元素是可变的，即便元组本身不可变，元素依然可变。
- 也就是说，元组的不可变性其 实是指 tuple 数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。

#### 默认做浅复制
- 复制列表（或多数内置的可变集合）最简单的方式是使用内置的类型构造方法。
- 对列表和其他可变序列来说，还能使用简洁的 l2 = l1[:] 语句创建副本。

#### 为任意对象做深复制和浅复制
- 浅复制没什么问题，但有时我们需要的是深复制（即副本不共享内部对象的引用）。copy 模块提供的 deepcopy 和 copy 函数能为任意对象做深复制和浅复制。
- 注意，一般来说，深复制不是件简单的事。如果对象有循环引用，那么这个朴素的算法会 进入无限循环。deepcopy 函数会记住已经复制的对象，因此能优雅地处理循环引用。
![](assets/Pasted%20image%2020220802190025.png)
- 此外，深复制有时可能太深了。例如，对象可能会引用不该复制的外部资源或单例值。我 们可以实现特殊方法 \_\_copy__() 和 \_\_deepcopy__()，控制 copy 和 deepcopy 的行为。

#### 函数的参数作为引用时
- Python 唯一支持的参数传递模式是共享传参（call by sharing）。多数面向对象语言都采用 这一模式。共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参 是实参的别名。
- 这种方案的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的 标识（即不能把一个对象替换成另一个对象）。

#### 不要使用可变类型作为参数的默认值
通常使用 None 作为接收可变值的参数的默认值。

#### 防御可变参数
- 如果定义的函数接收可变参数，应该谨慎考虑调用方是否期望修改传入的参数。 例如，如果函数接收一个字典，而且在处理的过程中要修改它，那么这个副作用要不要体 现到函数外部？具体情况具体分析。这其实需要函数的编写者和调用方达成共识。
- 除非这个方法确实想修改通过参数传入的对象，否则在类中直接把参数赋值 给实例变量之前一定要三思，因为这样会为参数对象创建别名。如果不确 定，那就创建副本。这样客户会少些麻烦。

#### del和垃圾回收
- del 语句删除名称，而不是对象。del 命令可能会导致对象被当作垃圾回收，但是仅当删除 的变量保存的是对象的最后一个引用，或者无法得到对象时。 重新绑定也可能会导致对象 的引用数量归零，导致对象被销毁。
- 如果两个对象相互引用，当它们的引用只存在二者之间时，垃圾回收程序会判定 它们都无法获取，进而把它们都销毁。
- 有个 \_\_del__ 特殊方法，但是它不会销毁实例，不应该在代码中调用。即将销 毁实例时，Python 解释器会调用 \_\_del__ 方法，给实例最后的机会，释放外部 资源。
- 在 CPython 中，垃圾回收使用的主要算法是引用计数。实际上，每个对象都会统计有多少 引用指向自己。当引用计数归零时，对象立即就被销毁：CPython 会在对象上调用 \_\_del__ 方法（如果定义了），然后释放分配给对象的内存。CPython 2.0 增加了分代垃圾回收算法， 用于检测引用循环中涉及的对象组——如果一组对象之间全是相互引用，即使再出色的引 用方式也会导致组中的对象不可获取。Python 的其他实现有更复杂的垃圾回收程序，而且 不依赖引用计数，这意味着，对象的引用数量为零时可能不会立即调用 \_\_del__ 方法。

#### 弱引用
- 弱引用不会增加对象的引用数量。引用的目标对象称为所指对象（referent）。因此我们说， 弱引用不会妨碍所指对象被当作垃圾回收。 
- 弱引用在缓存应用中很有用，因为我们不想仅因为被缓存引用着而始终保存缓存对象。
- Python 控制台会自动把 _ 变量绑定到结果不为 None 的表达式结果上。
- 微观管理内存时，往往会得到意外的结果，因为不明显的隐式赋值会 为对象创建新引用。控制台中的 _ 变量是一例。调用跟踪对象也常导致意料 之外的引用。
- 使用 weakref.ref 实例获取所指对象。如果对象存在，调用弱引用可 以获取对象；否则返回 None。
- 使用 weakref.finalize 注册一个回调函数， 在销毁对象时调用。
- weakref.ref 类其 实是低层接口，供高级用途使用，多数程序最好使用 weakref 集合和 finalize。也就是说， 应该使用 WeakKeyDictionary、WeakValueDictionary、WeakSet 和 finalize（在内部使用弱 引用），不要自己动手创建并处理 weakref.ref 实例。
- WeakValueDictionary 类实现的是一种可变映射，里面的值是对象的弱引用。被引用的对象 在程序中的其他地方被当作垃圾回收后，对应的键会自动从 WeakValueDictionary 中删除。 因此，WeakValueDictionary 经常用于缓存。
- 与 WeakValueDictionary 对应的是 WeakKeyDictionary， 后 者 的 键 是 弱 引 用。WeakKeyDictionary 实例可以为应用中其他部分拥有的对象附加数据，这样就无 需为对象添加属性。这对覆盖属性访问权限的对象尤其有用。
- weakref 模块还提供了 WeakSet 类，按照文档的说明，这个类的作用很简单：“保存元素弱 引用的集合类。元素没有强引用时，集合会把它删除。”如果一个类需要知道所有实例， 一种好的方案是创建一个 WeakSet 类型的类属性，保存实例的引用。

#### 弱引用的局限
- 不是每个 Python 对象都可以作为弱引用的目标（或称所指对象）。基本的 list 和 dict 实 例不能作为所指对象，但是它们的子类可以轻松地解决这个问题。
- int 和 tuple 实例不能作为弱引用的目标，甚至它们的子类也不行。 
- 这些局限基本上是 CPython 的实现细节，在其他 Python 解释器中情况可能不一样。这些局 限是内部优化导致的结果。

#### Python对不可变类型施加的把戏
- 这里讨论的是 Python 的实现细节，对 Python 用户来 说没那么重要。这些细节是 CPython 核心开发者走的捷径和做的优化措施， 对这门语言的用户而言无需了解，而且那些细节对其他 Python 实现可能没 用，CPython 未来的版本可能也不会用。尽管如此，在学习别名和副本的过 程中，你可能偶然见过这些把戏，因此我觉得有必要讲一下。
- 对元组 t 来说，t[:] 不创建副本，而是返回同一个对象的引用。此外， tuple(t) 获得的也是同一个元组的引用。
- 在 Python 控制台中输入 help(tuple)，你会看到这句话：“如果参数是一 个元组，那么返回值是同一个对象。
- str、bytes 和 frozenset 实例也有这种行为。注意，frozenset 实例不是序列，因此不能 使用 fs[:]（fs 是一个 frozenset 实例）。但是，fs.copy() 具有相同的效果：它会欺骗你， 返回同一个对象的引用，而不是创建一个副本。
- 共享字符串字面量是一种优化措施，称为驻留（interning）。千万不要依赖字符串或整数的驻留！比较字符串或整数是否相等时，应该使 用 \=\=，而不是 is。驻留是 Python 解释器内部使用的一个特性。

#### 变量保存的是引用
- 简单的赋值不创建副本。 
- 对 += 或 \*= 所做的增量赋值来说，如果左边的变量绑定的是不可变对象，会创建新对象； 如果是可变对象，会就地修改。
- 为现有的变量赋予新值，不会修改之前绑定的变量。这叫重新绑定：现在变量绑定了其 他对象。如果变量是之前那个对象的最后一个引用，对象会被当作垃圾回收。
- 函数的参数以别名的形式传递，这意味着，函数可能会修改通过参数传入的可变对象。 这一行为无法避免，除非在本地创建副本，或者使用不可变对象（例如，传入元组，而 不传入列表）。
- 使用可变类型作为函数参数的默认值有危险，因为如果就地修改了参数，默认值也就变 了，这会影响以后使用默认值的调用。

---
### 第九章 符合Python风格的对象
#### classmethod与staticmethod
- classmethod：定义操作类，而不是操作实例的方法。 classmethod 改变了调用方法的方式，因此类方法的第一个参数是类本身，而不是实例。 classmethod 最常见的用途是定义备选构造方法。
- staticmethod 装饰器也会改变方法的调用方式，但是第一个参数不是特殊的值。其实，静 态方法就是普通的函数，只是碰巧在类的定义体中，而不是在模块层定义。

#### Python的私有属性和“受保护的”属性
- Python 不能像 Java 那样使用 private 修饰符创建私有属性，但是 Python 有个简单的机制， 能避免子类意外覆盖“私有”属性。
- 如果以 \_\_mood 的形式（两个前导下划线，尾部没有或最多有一个下划 线）命名实例属性，Python 会把属性名存入实例的 \_\_dict__ 属性中，而且会在前面加上一 个下划线和类名。这个语言特性叫名称改写（name mangling）。
- Python 文档的某些角落把使用一个下划线前缀标记的属性称为“受保护的”属性。 使用 self.\_x 这种形式保护属性的做法很常见，但是很少有人把这种属性叫作“受保护的”属 性。有些人甚至将其称为“私有”属性。

#### 使用__slots__类属性节省空间
- 默认情况下，Python 在各个实例中名为 \_\_dict__ 的字典里存储实例属性。为了使用底层的散列表提升访问速度，字典会消耗大量内存。如果要处理数百万个属性不 多的实例，通过 \_\_slots__ 类属性，能节省大量内存，方法是让解释器在元组中存储实例 属性，而不用字典。
- 继承自超类的 \_\_slots__ 属性没有效果。Python 只会使用各个类中定义的 \_\_slots__ 属性。
- 定义 \_\_slots__ 的方式是，创建一个类属性，使用 \_\_slots__ 这个名字，并把它的值设为 一个字符串构成的可迭代对象，其中各个元素表示各个实例属性。一般使用元组，因为 这样定义的 \_\_slots__ 中所含的信息不会变化
- 在类中定义 \_\_slots__ 属性的目的是告诉解释器：“这个类中的所有实例属性都在这儿 了！”这样，Python 会在各个实例中使用类似元组的结构存储实例变量，从而避免使用消 耗内存的 \_\_dict__ 属性。
- 在类中定义 \_\_slots__ 属性之后，实例不能再有 \_\_slots__ 中所列名称之外 的其他属性。这只是一个副作用，不是 \_\_slots__ 存在的真正原因。不要使 用 \_\_slots__ 属性禁止类的用户新增实例属性。\_\_slots__ 是用于优化的，不 是为了约束程序员。
- 然而，“节省的内存也可能被再次吃掉”：如果把 '\_\_dict__' 这个名称添加到 \_\_slots__ 中，实例会在元组中保存各个实例的属性，此外还支持动态创建属性，这些属性存储在常 规的 \_\_dict__ 中。当然，把 '\_\_dict__' 添加到 \_\_slots__ 中可能完全违背了初衷，这取决 于各个实例的静态属性和动态属性的数量及其用法。粗心的优化甚至比提早优化还糟糕。
- 此外，还有一个实例属性可能需要注意，即 \_\_weakref__ 属性，为了让对象支持弱引用 （参见 8.6 节），必须有这个属性。用户定义的类中默认就有 \_\_weakref__ 属性。可是，如 果类中定义了 \_\_slots__ 属性，而且想把实例作为弱引用的目标，那么要把 '\_\_weakref__' 添加到 \_\_slots__ 中。

#### \_\_slots__的问题
- 每个子类都要定义 \_\_slots__ 属性，因为解释器会忽略继承的 \_\_slots__ 属性。 
- 实例只能拥有 \_\_slots__ 中列出的属性，除非把 '\_\_dict__' 加入\_\_slots__ 中（这样做 就失去了节省内存的功效）。
- 如果不把 '\_\_weakref__' 加入 \_\_slots__，实例就不能作为弱引用的目标。

#### 覆盖类属性
- Python 有个很独特的特性：类属性可用于为实例属性提供默认值。
- 但是，如果为不存在的实例属性赋值，会新建实例属性。
- 类属性是公开 的，因此会被子类继承，于是经常会创建一个子类，只用于定制类的数据属性。

---
### 第十章 序列的修改、散列和切片
#### 切片原理
- 调用 dir(slice) 得到的结果中有个 indices 属性，这个方法有很大的作 用，但是鲜为人知。help(slice.indices) 给出的信息如下：
 S.indices(len) -> (start, stop, stride) 
 给定长度为 len 的序列，计算 S 表示的扩展切片的起始（start）和结尾（stop）索 引，以及步幅（stride）。超出边界的索引会被截掉，这与常规切片的处理方式一样。 换句话说，indices 方法开放了内置序列实现的棘手逻辑，用于优雅地处理缺失索引和负 数索引，以及长度超过目标序列的切片。这个方法会“整顿”元组，把 start、stop 和 stride 都变成非负数，而且都落在指定长度序列的边界内。 
- 下面举几个例子。假设有个长度为 5 的序列，例如 'ABCDE'：
![](assets/Pasted%20image%2020220802225920.png)

#### 动态存取属性
- 属性查找失败后，解释器会调用 \_\_getattr__ 方法。简单来说，对 my_obj.x 表达式，Python 会检查 my_obj 实例有没有名为 x 的属性；如果没有，到类（my_obj.\_\_class__）中查找；如果 还没有，顺着继承树继续查找。如果依旧找不到，调用 my_obj 所属类中定义的 \_\_getattr__ 方法，传入 self 和属性名称的字符串形式（如 'x'）。
- 仅当对象没有指定名称的 属性时，Python 才会调用那个方法，这是一种后备机制。可是，像 v.x = 10 这样赋值之 后，v 对象有 x 属性了，因此使用 v.x 获取 x 属性的值时不会调用 \_\_getattr__ 方法了，解 释器直接返回绑定到 v.x 上的值，即 10。
- 多数时候，如果实 现了 \_\_getattr__ 方法，那么也要定义 \_\_setattr__ 方法，以防对象的行为不一致。

#### REDUCE和map
- 多数时候，如果实 现了 \_\_getattr__ 方法，那么也要定义 \_\_setattr__ 方法，以防对象的行为不一致。 
- 在 Python 3 中，map 函数是惰性的，它会创建一个生成器，按需产出 结果

---
### 第十一章 接口：从协议到抽象基类
#### 接口
- 关于接口，这里有个实用的补充定义：对象公开方法的子集，让对象在系统中扮演特定的角色。

#### 序列协议
![](assets/Pasted%20image%2020220803195018.png)
- 虽然没有 \_\_iter__ 方法，但是 Foo 实例是可迭代的对象，因为发现有 \_\_getitem__ 方法时， Python 会调用它，传入从 0 开始的整数索引，尝试迭代对象（这是一种后备机制）。尽管 没有实现 \_\_contains__ 方法，但是 Python 足够智能，能迭代 Foo 实例，因此也能使用 in 运算符：Python 会做全面检查，看看有没有指定的元素。
- 综上，鉴于序列协议的重要性，如果没有 \_\_iter__ 和 \_\_contains__ 方法，Python 会调用 \_\_getitem__ 方法，设法让迭代和 in 运算符可用。

#### 猴子补丁
- 在运行时修改类或模块，而不改动源码

#### 鸭子类型
- 对象的类型无关紧要，只要实现了特定的协议即可。

#### 定义抽象基类的子类
- 导入时（加载并编译模块时），Python 不会检查抽象方法的实现，在运行时 实例化类时才会真正检查。
- ![](assets/Pasted%20image%2020220803201334.png)

#### 标准库中的抽象基类
- 大多数抽象基类在 collections.abc 模块中定 义，不过其他地方也有。例如，numbers 和 io 包中有一些抽象基类。但是，collections. abc 中的抽象基类最常用。
- 标准库中有两个名为 abc 的模块，这里说的是 collections.abc。为了减少加 载时间，Python 3.4 在 collections 包之外实现这个模块（在 Lib/\_collections_ abc.py 中），因此要 与 collections 分开导入。另一个 abc 模块就是 abc（即 Lib/abc.py），这里定义的是 abc.ABC 类。每个抽象 基类都依赖这个类，但是不用导入它，除非定义新抽象基类。
- ![](assets/Pasted%20image%2020220803205300.png)
- Iterable、Container 和 Sized：各个集合应该继承这三个抽象基类，或者至少实现兼容的协议。Iterable 通过 \_\_iter__ 方法支持迭代，Container 通过 \_\_contains__ 方法支持 in 运算符，Sized 通过 \_\_len__ 方法支持 len() 函数。
- Sequence、Mapping 和 Set：这三个是主要的不可变集合类型，而且各自都有可变的子类。
- MappingView：在 Python 3中，映射方法 .items()、.keys() 和 .values() 返回的对象分别是 ItemsView、 KeysView 和 ValuesView 的实例。
- Callable 和 Hashable：这两个抽象基类与集合没有太大的关系，只不过因为 collections.abc 是标准库中定义 抽象基类的第一个模块，而它们又太重要了，因此才把它们放到 collections.abc 模块 中。我从未见过 Callable 或 Hashable 的子类。这两个抽象基类的主要作用是为内置函 数 isinstance 提供支持，以一种安全的方式判断对象能不能调用或散列。
- Iterator：注意它是 Iterable 的子类。
- 若想检查是否能调用，可以使用内置的 callable() 函数；但是没有类似的 hashable() 函数，因此测 试对象是否可散列，最好使用 isinstance(my_obj, Hashable)。

#### 抽象基类的数字塔
- numbers 包定义的是“数字塔”（即各个抽象基类的层次结构是线性的），其中 Number 是位于最顶端的超类，随后是 Complex 子类， 依次往下，最底端是 Integral 类： 
	- Number
	- Complex
	- Real
	- Rational
	- Integral 

- 因此，如果想检查一个数是不是整数，可以使用 isinstance(x, numbers.Integral)，这样 代码就能接受 int、bool（int 的子类），或者外部库使用 numbers 抽象基类注册的其他类 型。为了满足检查的需要，你或者你的 API 的用户始终可以把兼容的类型注册为 numbers. Integral 的虚拟子类。
- decimal.Decimal 没有注册为 numbers.Real 的虚拟子类，这有点奇怪。没注 册的原因是，如果你的程序需要 Decimal 的精度，要防止与其他低精度数字 类型混淆，尤其是浮点数。

#### 定义并使用一个抽象基类
![](assets/Pasted%20image%2020220803210732.png)
- 其实，抽象方法可以有实现代码。即便实现了，子类也必须覆盖抽象方法， 但是在子类中可以使用 super() 函数调用抽象方法，为它添加功能，而不是 从头开始实现。

#### 异常类的部分层次结构
![](assets/Pasted%20image%2020220803211157.png)

#### 抽象基类句法详解
- 声明抽象基类最简单的方式是继承 abc.ABC 或其他抽象基类。 
- 然而，abc.ABC 是 Python 3.4 新增的类，因此如果你使用的是旧版 Python，并且继承现 有的抽象基类也不可取时，必须在 class 语句中使用 metaclass= 关键字，把值设为 abc. ABCMeta（不是 abc.ABC）。可以写成：
```python
class Tombola(metaclass=abc.ABCMeta):
	# ...
```
- metaclass= 关键字参数是 Python 3 引入的。在 Python 2 中必须使用 \_\_metaclass__ 类属性： ```
```python
class Tombola(object):
	# 这是Python 2！！！ 
	__metaclass__ = abc.ABCMeta 
	# ...
```
- 除了 @abstractmethod 之外，abc 模块还定义了 @abstractclassmethod、@abstractstaticmethod 和 @abstractproperty 三个装饰器。然而，后三个装饰器从 Python 3.3 起废弃了，因为装饰器 可以在 @abstractmethod 上堆叠，那三个就显得多余了。
- 在函数上堆叠装饰器的顺序通常很重要，@abstractmethod 的文档就特别指出：与其他方法描述符一起使用时，abstractmethod() 应该放在最里 层。 也就是说，在 @abstractmethod 和 def 语句之间不能有其他装饰器。

#### 使用 register 方法声明虚拟子类
- 注册虚拟子类的方式是在抽象基类上调用 register 方法。这么做之后，注册的类会变成抽 象基类的虚拟子类，而且 issubclass 和 isinstance 等函数都能识别，但是注册的类不会 从抽象基类中继承任何方法或属性。
- 虚拟子类不会继承注册的抽象基类，而且任何时候都不会检查它是否符合抽 象基类的接口，即便在实例化时也不会检查。为了避免运行时错误，虚拟子 类要实现所需的全部方法。
- register 方法通常作为普通的函数调用，不过也可以作为装饰器使用。
- 类的继承关系在一个特殊的类属性中指定——\_\_mro__，即方法解析顺序（Method Resolution Order）。这个属性的作用很简单，按顺序列出类及其超类，Python 会按照这个 顺序搜索方法。
- \_\_subclasses__()：这个方法返回类的直接子类列表，不含虚拟子类。
- \_abc_registry：只有抽象基类有这个数据属性，其值是一个 WeakSet 对象，即抽象类注册的虚拟子类的 弱引用。
- 内 置 类 型 tuple、str、range 和 memoryview 注册为 Sequence 的虚拟子类：
```python
Sequence.register(tuple) 
Sequence.register(str) 
Sequence.register(range) 
Sequence.register(memoryview)
```

#### 即便不注册，抽象基类也能把一个类识别为虚拟子类
![](assets/Pasted%20image%2020220803215514.png)

---
### 第十二章 继承的优缺点
#### 子类化内置类型很麻烦
- 内置类型（使用 C 语言编写）不会调用用户定义的类覆盖的特殊方法。
- 基本上，内置类型的方法不会调用子类覆盖的方法。例如，dict 的子类覆盖的 \_\_getitem__() 方法不会被内置类型的 get() 方法调用。
- 不要子类化内置类型，用户自己定义的类应 该继承 collections 模块中的类，例如 UserDict、UserList 和 UserString，这些类做了特殊设计，因此 易于扩展。
- 所述的问题只发生在 C 语言实现的内置类型内部的方法委托上，而且只影响 直接继承内置类型的用户自定义类。

#### 多重继承和方法解析顺序
- 任何实现多重继承的语言都要处理潜在的命名冲突，这种冲突由不相关的祖先类实现同名 方法引起。这种冲突称为“菱形问题”。
![](assets/Pasted%20image%2020220803221142.png)
- 若想把方法调用委托给超类，推荐的方式是使用内置的 super() 函数。使用 super() 调用方法时，会遵守方法解析顺序
- 直接在类上调用实例方法时，必须显式传入 self 参数，因为这样访问的是未绑定方 法（unbound method）
```python
def ping(self): 
	A.ping(self) # 而不是super().ping()
```
- 方法解析顺序不仅考虑继承图，还考虑子类声明中列出超类的顺序。
- 方法解析顺序使用 C3 算法计算。

#### 处理多重继承
- 把接口继承和实现继承区分开：继承接口，创建子类型，实现“是什么”关系 ； 继承实现，通过重用避免代码重复。
- 使用抽象基类显式表示接口：现代的 Python 中，如果类的作用是定义接口，应该明确把它定义为抽象基类。
- 通过混入重用代码：从概念上讲，混入不定义 新类型，只是打包方法，便于重用。混入类绝对不能实例化，而且具体类不能只继承混入 类。混入类应该提供某方面的特定行为，只实现少量关系非常紧密的方法。
- 在名称中明确指明混入：因为在 Python 中没有把类声明为混入的正规方式，所以强烈推荐在名称中加入 ...Mixin 后缀。
- 抽象基类可以作为混入，反过来则不成立：抽象基类可以实现具体方法，因此也可以作为混入使用。不过，抽象基类会定义类型，而 混入做不到。此外，抽象基类可以作为其他类的唯一基类，而混入决不能作为唯一的超 类。抽象基类中实现的具体方法只能与抽象基类及其超类中 的方法协作。
- 不要同时继承多个具体类：具体类可以没有，或最多只有一个具体超类。也就是说，具体类的超类中除了这一个具体 超类之外，其余的都是抽象基类或混入。
- 为用户提供聚合类：如果抽象基类或混入的组合对客户代码非常有用，那就提供一个类，使用易于理解的方式 把它们结合起来。
- 优先使用对象组合，而不是类继承。

---
### 第十三章 正确重载运算符
#### 运算符重载基础
Python 施加了一些限制，做好了灵活性、可用性和安全性方面的平衡：
- 不能重载内置类型的运算符
- 不能新建运算符，只能重载现有的
- 某些运算符不能重载——is、and、or 和 not（不过位运算符 &、| 和 ~ 可以）

#### 一元运算符
- 要遵守运算符的一个基本规则：始终返回一个 新对象。也就是说，不能修改 self，要创建并返回合适类型的新实例。
- 实现一元运算符和中缀运算符的特殊方法一定不能修改操作数。使用这些运算符的表达式期待结果是新对象。只有增量赋值表达式可能会修改第一个操 作数（self）。

#### 中缀运算符
为了支持涉及不同类型的运算，Python 为中缀运算符特殊方法提供了特殊的分派机制。对 表达式 a + b 来说，解释器会执行以下几步操作：
- 如果 a 有 \_\_add__ 方法，而且返回值不是 NotImplemented，调用 a.\_\_add__(b)，然后返回结果。
- 如果 a 没有 \_\_add__ 方法，或者调用 \_\_add__ 方法返回 NotImplemented，检查 b 有没有 \_\_radd__ 方法，如果有，而且没有返回 NotImplemented，调用 b.\_\_radd__(a)，然后返回结果。
- 如果 b 没有 \_\_radd__ 方法，或者调用 \_\_radd__ 方法返回 NotImplemented，抛出 TypeError， 并在错误消息中指明操作数类型不支持。
![](assets/Pasted%20image%2020220803224740.png)
- 别把 NotImplemented 和 NotImplementedError 搞混了。前者是特殊的单例值， 如果中缀运算符特殊方法不能处理给定的操作数，那么要把它返回（return） 给解释器。而 NotImplementedError 是一种异常，抽象类中的占位方法把它抛 出（raise），提醒子类必须覆盖。
- 如果由于类型不兼容而 导致运算符特殊方法无法返回有效的结果，那么应该返回 NotImplemented，而不是抛出 TypeError。返回 NotImplemented 时，另一个操作数所属的类型还有机会执行运算，即 Python 会尝试调用反向方法。![](assets/Pasted%20image%2020220810172017.png)
![](assets/Pasted%20image%2020220803225540.png)
![](assets/Pasted%20image%2020220803225606.png)
- 如果操作数的类型不同，我们要检测出不能处理的操作数。本章使用两种方式处理这个问 题：一种是鸭子类型，直接尝试执行运算，如果有问题，捕获 TypeError 异常；另一种是 显式使用 isinstance 测试，\_\_mul__ 方法就是这么做的。这两种方式各有优缺点：鸭子类 型更灵活，但是显式检查更能预知结果。如果选择使用 isinstance，要小心，不能测试具 体类，而要测试 numbers.Real 抽象基类，例如 isinstance(scalar, numbers.Real)。这在 灵活性和安全性之间做了很好的折中，因为当前或未来由用户定义的类型可以声明为抽象 基类的真实子类或虚拟子类。

#### 比较运算符
Python 解释器对众多比较运算符（\=\=、!=、>、<、>=、<=）的处理与前文类似，不过在两 个方面有重大区别。
- 正向和反向调用使用的是同一系列方法。这方面的规则如表 13-2 所示。例如，对 == 来说， 正向和反向调用都是 \_\_eq__ 方法，只是把参数对调了；而正向的 \_\_gt__ 方法调用的是 反向的 \_\_lt__ 方法，并把参数对调。
- 对 == 和 != 来说，如果反向调用失败，Python 会比较对象的 ID，而不抛出 TypeError。返回 
![](assets/Pasted%20image%2020220803225948.png)
- [1,2] == (1, 2) 的结果是 False。
- 重载了\==运算符后，!= 我们不用实现它，因为从 object 继承的 \_\_ne__ 方法的后备行为满足了 我们的需求：定义了 \_\_eq__ 方法，而且它不返回 NotImplemented，\_\_ne__ 会对 \_\_eq__ 返 回的结果取反。

#### 增量赋值运算符
- 增量赋值不会修改不可变目标，而是新建实例，然后重新绑定
- 如果定义了 \_\_add__ 方法的话，不用编写额外的代码，+= 就能使用。a += b 的 作用与 a = a + b 完全一样。对不可变类型来说，这是预期的行为。
- 如果实现了就地运算符方法，例如 \_\_iadd__，计算 a += b 的结果时会调用就地运算 符方法。这种运算符的名称表明，它们会就地修改左操作数，而不会创建新对象作为结果。
- 注意，与 + 相比，+= 运算符对第二个操作数更宽容。+ 运算符的两个操作数必须是相同类 型，如若不然，结果的类型可能让人摸不着头脑。而 += 的情 况更明确，因为就地修改左操作数，所以结果的类型是确定的。
- 增量赋值特殊方法必须返回 self。
- 一般来说，如果中缀运算符的正向方法（如 \_\_mul__）只处理与 self 属于同 一类型的操作数，那就无需实现对应的反向方法（如 \_\_rmul__），因为按照 定义，反向方法是为了处理类型不同的操作数。

---
### 第十四章 可迭代的对象、迭代器和生成器
#### yield关键字
yield用于构建生成器（generator），其作用与迭代器一样。所有生成器都是迭代器，因为生成器完全实现了迭代器接口。~~不过，根据《设计模式：可复用面向对象软件的基础》一书的定义，迭代器用于从集合中取出 元素；而生成器用于“凭空”生成元素。~~

在 Python 中，所有集合都可以迭代。在 Python 语言内部，迭代器用于支持：
- for 循环 
- 构建和扩展集合类型
- 逐行遍历文本文件
- 列表推导、字典推导和集合推导
- 元组拆包
- 调用函数时，使用 * 拆包实参

#### iter函数
解释器需要迭代对象 x 时，会自动调用 iter(x)。内置的 iter 函数有以下作用：
- 检查对象是否实现了 \_\_iter__ 方法，如果实现了就调用它，获取一个迭代器。
- 如果没有实现 \_\_iter__ 方法，但是实现了 \_\_getitem__ 方法，Python 会创建一个迭代 器，尝试按顺序（从索引 0 开始）获取元素。(\_\_getitem__ 方法的参数是从 0 开始的整数（int）， 这样才认为对象是可迭代的)
- 如果尝试失败，Python 抛出 TypeError 异常，通常会提示“C object is not iterable”（C 对象不可迭代），其中 C 是目标对象所属的类。
- 如果 实现了 \_\_iter__ 方法，那么就认为对象是可迭代的。此时，不需要创建子类，也不用注册， 因为 abc.Iterable 类实现了 \_\_subclasshook__ 方法
- 从 Python 3.4 开始，检查对象 x 能否迭代，最准确的方法是：调用 iter(x) 函数，如果不可迭代，再处理 TypeError 异常。这比使用 isinstance(x, abc.Iterable) 更准确，因为 iter(x) 函数会考虑到遗留的 \_\_getitem__ 方 法，而 abc.Iterable 类则不考虑。

#### 可迭代的对象与迭代器的对比
- 明确可迭代的对象和迭代器之间的关系：Python 从可迭代的对象中获取迭代器。
- 可迭代的对象：使用 iter 内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的 \_\_iter__ 方法，那么对象就是可迭代的。序列都可以迭代；实现了 \_\_getitem__ 方法，而且其参 数是从零开始的索引，这种对象也可以迭代。
- 如果没有 for 语句，不得不使用 while 循环模拟，要像下面这样写：
![](assets/Pasted%20image%2020220805145126.png|450)
- StopIteration 异常表明迭代器到头了。Python 语言内部会处理 for 循环和其他迭代上下 文（如列表推导、元组拆包，等等）中的 StopIteration 异常。

#### 迭代器
- 迭代器：迭代器是这样的对象：实现了无参数的 \_\_next__ 方法，返回序列中的下一个元素；如 果没有元素了，那么抛出 StopIteration 异常。Python 中的迭代器还实现了 \_\_iter__ 方 法，因此迭代器也可以迭代。

- 标准的迭代器接口有两个方法：
	- \_\_next__：返回下一个可用的元素，如果没有元素了，抛出 StopIteration 异常。 
	- \_\_iter__：返回 self，以便在应该使用可迭代对象的地方使用迭代器，例如在 for 循环中。

- 这个接口在 collections.abc.Iterator 抽象基类中制定。这个类定义了 \_\_next__ 抽象方法， 而且继承自 Iterable 类；\_\_iter__ 抽象方法则在 Iterable 类中定义。
![](assets/Pasted%20image%2020220805152500.png)

- 因为迭代器只需 \_\_next__ 和 \_\_iter__ 两个方法，所以除了调用 next() 方法，以及捕获 StopIteration 异常之外，没有办法检查是否还有遗留的元素。此外，也没有办法“还原” 迭代器。如果想再次迭代，那就要调用 iter(...)，传入之前构建迭代器的可迭代对象。 传入迭代器本身没用，因为前面说过 Iterator.\_\_iter__ 方法的实现方式是返回实例本身， 所以传入迭代器无法还原已经耗尽的迭代器。
- 可迭代的对象一定不能是自身的迭代器。也就是说，可迭代的对象必须实现 \_\_iter__ 方法，但不能实现 \_\_next__ 方法。 
- 另一方面，迭代器应该一直可以迭代。迭代器的 \_\_iter__ 方法应该返回自身。

#### 生成器函数
- 只要 Python 函数的定义体中有 yield 关键字，该函数就是生成器函数。调用生成器函数 时，会返回一个生成器对象（实现了迭代器接口）。也就是说，生成器函数是生成器工厂。
![](assets/Pasted%20image%2020220805161658.png)
- 生成器函数定义体中的 return 语句会 触发生成器对象抛出 StopIteration 异常。调用方可以从异常对象中获取返回值。可是，只有把生 成器函数当成协程使用时，这么做才有意义。
- re.finditer 函数是 re.findall 函数的惰性版本，返回的不是列表，而是一个生成器，按 需生成 re.MatchObject 实例。
![](assets/Pasted%20image%2020220805164929.png)

#### 生成器表达式
- 生成器表达式可以理解为列表推导的惰性版本：不会迫切地构建列表，而是返回一个生成 器，按需惰性生成元素。
![](assets/Pasted%20image%2020220805164702.png)
- 生成器表达式是语法糖：完全可以替换成生成器函数，不过有时使用生成器表达式更便 利。
- 选择使用哪种句法很容易判断：如果生成器表达式要分成多行写，我倾向 于定义生成器函数，以便提高可读性。此外，生成器函数有名称，因此可以重用。
- 如果函数或构造方法只有一个参数，传入生成器表达式时不用写一对调用函 数的括号，再写一对括号围住生成器表达式，只写一对括号就行了。然而，如 果生成器表达式后面还有其他参数，那么必须使用括号围住，否则会抛出 SyntaxError 异常。
- 生成器当作典型的迭代器使用，即从集合中获取 元素。不过，生成器也可用于生成不受数据源限制的值。

#### 标准库中的生成器函数
![](assets/Pasted%20image%2020220805174733.png)
![](assets/Pasted%20image%2020220805175249.png)
![](assets/Pasted%20image%2020220805194229.png)
![](assets/Pasted%20image%2020220805194543.png)
![](assets/Pasted%20image%2020220805202520.png)

#### yield from
- 这个语句的 作用就是把不同的生成器结合在一起使用。
- 如果生成器函数需要产出另一个生成器生成的值，传统的解决方法是使用嵌套的 for 循环。例如：
```python
def chain(*iterables):
	for it in iterables:
		for i in it:
			yield i
```
`PEP-380`引入了一个新句法，如下
```python
def chain(*iterables):
	for i in iterables:
		yield from i
```
可以看出，yield from i 完全代替了内层的 for 循环。在这个示例中使用 yield from 是对 的，而且代码读起来更顺畅，不过感觉更像是语法糖。除了代替循环之外，yield from 还 会创建通道，把内层生成器直接与外层生成器的客户端联系起来。把生成器当成协程使用 时，这个通道特别重要，不仅能为客户端代码生成值，还能使用客户端代码提供的值。
- yield from 不只是语法糖。

#### 可迭代的归约函数
- 这里列出的每个内置函数都可以使用 functools.reduce 函数实现，内置是因为使用它们便于解决常见的问题。此外，对 all 和 any 函数来说，有一项重要的优化措施是 reduce 函数做不到的：这两个函数会短路（即一 旦确定了结果就立即停止使用迭代器）。
![](assets/Pasted%20image%2020220805221149.png)
- 还有一个内置的函数接受一个可迭代的对象，返回不同的值——sorted。reversed 是生成 器函数，与此不同，sorted 会构建并返回真正的列表。毕竟，要读取输入的可迭代对象中 的每一个元素才能排序，而且排序的对象是列表，因此 sorted 操作完成后返回排序后的列 表。我在这里提到 sorted，是因为它可以处理任意的可迭代对象。

#### 深入分析iter函数
- iter 函数还有一个鲜为人知的用法：传入两个参数，使用常规的函数或任何可调 用的对象创建迭代器。这样使用时，第一个参数必须是可调用的对象，用于不断调用（没 有参数），产出各个值；第二个值是哨符，这是个标记值，当可调用的对象返回这个值时， 触发迭代器抛出 StopIteration 异常，而不产出哨符。
- 下述示例展示如何使用 iter 函数掷骰子，直到掷出 1 点为止：
```python
>>> def d6(): 
>>> ... return randint(1, 6) 
>>> ... 
>>> d6_iter = iter(d6, 1) 
>>> d6_iter
<callable_iterator object at 0x00000000029BE6A0>
```
- 注意，这里的 iter 函数返回一个 callable_iterator 对象。
- 与常规的迭代器一样，这个示例中的 d6_iter 对象一旦耗尽就没用了。如果想重新开始，必须再次调用 iter(...)，重新构建迭 代器
- 内置函数 iter 的文档中有个实用的例 子。这段代码逐行读取文件，直到遇到空行或者到达文件末尾为止：
```python
with open('mydata.txt') as fp: 
	for line in iter(fp.readline, '\n'): 
		process_line(line)
```

#### 把生成器当成协程
- PEP342这 个提案为生成器对象添加了额外的方法和功能，其中最值得关注的是 .send() 方法。
- 与 .\_\_next__() 方 法 一 样，.send() 方法致使生成器前进到下一个 yield 语 句。 不 过，.send() 方法还允许使用生成器的客户把数据发给自己，即不管传给 .send() 方法 什么参数，那个参数都会成为生成器函数定义体中对应的 yield 表达式的值。也就是 说，.send() 方法允许在客户代码和生成器之间双向交换数据。而 .\_\_next__() 方法只允许 客户从生成器中获取数据。
- 这是一项重要的“改进”，甚至改变了生成器的本性：像这样使用的话，生成器就变身为协 程。
- 生成器用于生成供迭代的数据。
- 协程是数据的消费者。
- 为了避免脑袋炸裂，不能把这两个概念混为一谈。
- 协程与迭代无关。
- 注意，虽然在协程中会使用 yield 产出值，但这与迭代无关。

---
### 第十五章 上下文管理器和else块
#### if语句之外的else块
- else 子句不仅能在 if 语句中使用，还 能在 for、while 和 try 语句中使用。
- for/else、while/else 和 try/else 的语义关系紧密，不过与 if/else 差别很大。
- else 子句的行为如下：
	- for：仅当 for 循环运行完毕时（即 for 循环没有被 break 语句中止）才运行 else 块。
	- while：仅当 while 循环因为条件为假值而退出时（即 while 循环没有被 break 语句中止）才运 行 else 块。
	- try：仅当 try 块中没有异常抛出时才运行 else 块。官方文档（https://docs.python.org/3/ reference/compound_stmts.html）还指出：“else 子句抛出的异常不会由前面的 except 子 句处理。”
- 在所有情况下，如果异常或者 return、break 或 continue 语句导致控制权跳到了复合语句 的主块之外，else 子句也会被跳过。
- 我觉得除了 if 语句之外，其他语句选择使用 else 关键字是个错误。else 蕴 含着“排他性”这层意思，例如“要么运行这个循环，要么做那件事”。可是， 在循环中，else 的语义恰好相反：“运行这个循环，然后做那件事。”因此， 使用 then 关键字更好。then 在 try 语句的上下文中也说得通：“尝试运行这 个，然后做那件事。”可是，添加新关键字属于语言的重大变化，而 Guido 唯 恐避之不及。
- 一开始，你可能觉得没必要在 try/except 块中使用 else 子句。毕竟，在下述代码片段中， 只有 dangerous_call() 不抛出异常，after_call() 才会执行，对吧？
```python
try: 
	dangerous_call() 
	after_call() 
except OSError: 
	log('OSError...')
```
然而，after_call() 不应该放在 try 块中。为了清晰和准确，try 块中应该只抛出预期异 常的语句。因此，像下面这样写更好：
```python
try: 
	dangerous_call() 
except OSError: 
	log('OSError...') 
else: 
	after_call()
```
现在很明确，try 块防守的是 dangerous_call() 可能出现的错误，而不是 after_call()。 而且很明显，只有 try 块不抛出异常，才会执行 after_call()。
- 在 Python 中，try/except 不仅用于处理错误，还常用于控制流程。为此，Python 官方词汇表还定义了一个缩略词（口号）：
	- EAFP：取得原谅比获得许可容易（easier to ask for forgiveness than permission）。先假定存在有效的键或属性，如果假定不成立，那 么捕获异常。
	- LBYL：三思而后行（look before you leap）。这种编程风格在调用函数或查找属性或键之 前显式测试前提条件。与 EAFP 风格相反，这种风格的特点是代码中有很多 if 语句。
- 如果选择使用 EAFP 风格，那就要更深入地了解 else 子句，并在 try/except 语句中合理 使用。

#### 上下文管理器和with块
- 上下文管理器对象存在的目的是管理 with 语句，就像迭代器的存在是为了管理 for 语句 一样。
- with 语句的目的是简化 try/finally 模式。这种模式用于保证一段代码运行完毕后执行某 项操作，即便那段代码由于异常、return 语句或 sys.exit() 调用而中止，也会执行指定的 操作。finally 子句中的代码通常用于释放重要的资源，或者还原临时变更的状态。
- 上下文管理器协议包含 \_\_enter__ 和 \_\_exit__ 两个方法。with 语句开始运行时，会在上下 文管理器对象上调用 \_\_enter__ 方法。with 语句运行结束后，会在上下文管理器对象上调 用 \_\_exit__ 方法，以此扮演 finally 子句的角色。
- 执行 with 后面的表达式 得到的结果是上下文管理器对象，不过，把值绑定到目标变量上（as 子句）是在上下文管 理器对象上调用 \_\_enter__ 方法的结果。
- 与函数和模块不同，with 块没有定义新的作用域。
![](assets/Pasted%20image%2020220805230642.png)
- 碰巧，示例 15-1 中的 open() 函数返回 TextIOWrapper 类的实例，而该实例的 \_\_enter__ 方 法返回 self。不过，\_\_enter__ 方法除了返回上下文管理器之外，还可能返回其他对象。
- 不管控制流程以哪种方式退出 with 块，都会在上下文管理器对象上调用 \_\_exit__ 方法， 而不是在 \_\_enter__ 方法返回的对象上调用。
- with 语句的 as 子句是可选的。对 open 函数来说，必须加上 as 子句，以便获取文件的引 用。不过，有些上下文管理器会返回 None，因为没什么有用的对象能提供给用户。
- 解释器调用 \_\_enter__ 方法时，除了隐式的 self 之外，不会传入任何参数。传给 \_\_exit__ 方法的三个参数列举如下：
	- exc_type：异常类（例如 ZeroDivisionError）。
	- exc_value：异常实例。有时会有参数传给异常构造方法，例如错误消息，这些参数可以使用 exc_ value.args 获取。
	- traceback：traceback 对象。


#### contextlib模块中的实用工具
**redirect_stdout：** 在实际使用中，如果应用程序接管了标准输出，可能会暂时把 sys.stdout 换 成类似文件的其他对象，然后再切换成原来的版本。只需传入类似文件的对象，用于替代 sys. stdout。
**closing：** 如果对象提供了 close() 方法，但没有实现 \_\_enter__/\_\_exit__ 协议，那么可以使用这 个函数构建上下文管理器。
**suppress：** 构建临时忽略指定异常的上下文管理器。
**@contextmanager：** 这个装饰器把简单的生成器函数变成上下文管理器，这样就不用创建类去实现管理器协 议了。
**ContextDecorator：** 这是个基类，用于定义基于类的上下文管理器。这种上下文管理器也能用于装饰函数， 在受管理的上下文中运行整个函数。
**ExitStack：** 这个上下文管理器能进入多个上下文管理器。with 块结束时，ExitStack 按照后进先出的 顺序调用栈中各个上下文管理器的 \_\_exit__ 方法。如果事先不知道 with 块要进入多少个 上下文管理器，可以使用这个类。例如，同时打开任意一个文件列表中的所有文件。

#### 使用@contextmanager
- 在使用 @contextmanager 装饰的生成器中，yield 语句的作用是把函数的定义体分成两部 分：yield 语句前面的所有代码在 with 块开始时（即解释器调用 \_\_enter__ 方法时）执行， yield 语句后面的代码在 with 块结束时（即调用 \_\_exit__ 方法时）执行。
- contextlib.contextmanager 装饰器会把函数包装成实现 \_\_enter__ 和 \_\_exit__ 方法 的类。这个类的 \_\_enter__ 方法有如下作用：
	- 调用生成器函数，保存生成器对象（这里把它称为 gen）。
	- 调用 next(gen)，执行到 yield 关键字所在的位置。
	- 返回 next(gen) 产出的值，以便把产出的值绑定到 with/as 语句中的目标变量上。
- with 块终止时，\_\_exit__ 方法会做以下几件事：
	- 检查有没有把异常传给 exc_type；如果有，调用 gen.throw(exception)，在生成器函数 定义体中包含 yield 关键字的那一行抛出异常。
	- 否则，调用 next(gen)，继续执行生成器函数定义体中 yield 语句之后的代码。
- 如果在 with 块中抛出了异常，Python 解释器会将其捕获， 然后在生成器函数的 yield 表达式里再次抛出。如果那里没有处理错误的代码， 生成器函数会中止，无法执行yield之后的代码。
- 为了告诉解释器异常已经处理了，\_\_exit__ 方法会返回 True，此时解释器会压制 异常。如果 \_\_exit__ 方法没有显式返回一个值，那么解释器得到的是 None，然后向上冒泡异 常。使用 @contextmanager 装饰器时，默认的行为是相反的：装饰器提供的 \_\_exit__ 方法假定 发给生成器的所有异常都得到处理了，因此应该压制异常。如果不想让 @contextmanager 压 制异常，必须在被装饰的函数中显式重新抛出异常。
- 使用 @contextmanager 装饰器时，要把 yield 语句放在 try/finally 语句中 （或者放在 with 语句中），这是无法避免的，因为我们永远不知道上下文管理器 的用户会在 with 块中做什么。

---
### 第十六章 协程
#### 生成器如何进化成协程
- 字典为动词“to yield”给出了两个释义：产出和让步。对于 Python 生成器中的 yield 来 说，这两个含义都成立。yield item 这行代码会产出一个值，提供给 next(...) 的调用方； 此外，还会作出让步，暂停执行生成器，让调用方继续工作，直到需要使用另一个值时再 调用 next()。调用方会从生成器中拉取值。
- 从句法上看，协程与生成器类似，都是定义体中包含 yield 关键字的函数。可是，在协程 中，yield 通常出现在表达式的右边（例如，datum = yield），可以产出值，也可以不产 出——如果 yield 关键字后面没有表达式，那么生成器产出 None。协程可能会从调用方接 收数据，不过调用方把数据提供给协程使用的是 .send(datum) 方法，而不是 next(...) 函 数。通常，调用方会把值推送给协程。
- yield 关键字甚至还可以不接收或传出数据。不管数据如何流动，yield 都是一种流程控制 工具，使用它可以实现协作式多任务：协程可以把控制器让步给中心调度程序，从而激活 其他的协程。
- 生成器的调用方 可以使用 .send(...) 方法发送数据，发送的数据会成为生成器函数中 yield 表达式的值。 因此，生成器可以作为协程使用。
- 协程是指一个过程，这个过程与调用方协作，产出由调 用方提供的值。
- 除了 .send(...) 方法，PEP 342 还添加了 .throw(...) 和 .close() 方法：前者的作用是让 调用方抛出异常，在生成器中处理；后者的作用是终止生成器。
- 现在，生成器可以返回一个值；以前，如果在生成器中给 return 语句提供值，会抛出 SyntaxError 异常。
- yield from 句法，使用它可以把复杂的生成器重构成小型的嵌套生成器，省 去了之前把生成器的工作委托给子生成器所需的大量样板代码。

#### 用作协程的生成器的基本行为
- 协程可以身处四个状态中的一个。当前状态可以使用 inspect.getgeneratorstate(...) 函 数确定，该函数会返回下述字符串中的一个：
	- 'GEN_CREATED' 等待开始执行。 
	- 'GEN_RUNNING' 解释器正在执行。
	- 'GEN_SUSPENDED' 在 yield 表达式处暂停。 
	- 'GEN_CLOSED' 执行结束。
- 最先调用 next(my_coro) 函数这一步通常称为“预激”（prime）协程（即，让协程向前执 行到第一个 yield 表达式，准备好作为活跃的协程使用）。
- 始终要调用 next(my_coro) 激活协程——也可以调用 my_coro.send(None)，效果一样。
- 关键的一点是，协程在 yield 关键字所在的位置暂停执行。前面说过，在赋值语句中，= 右边的代码在赋值之前执行。因此，对于 b = yield a 这行代码来说，等到客户端代码再 激活协程时才会设定 b 的值。

#### 使用协程计算移动平均值
![](assets/Pasted%20image%2020220806083334.png)
使用协程的好处是，total 和 count 声明为局部变量即可，无需使用实例属性或闭包在多 次调用之间保持上下文。

#### 预激协程的装饰器
- 很多框架都提供了处理协程的特殊装饰器，不过不是所有装饰器都用于预激协程，有些会 提供其他服务，例如勾入事件循环。
- 使用 yield from 句法调用协程时，会自动预激。Python 3.4 标准库里的 asyncio.coroutine 装饰器不会预激协程，因此能兼容 yield from 句法。

#### 终止协程和异常处理
- 协程中未处理的异常会向上冒泡，传给 next 函数或 send 方法的调用方（即触发协程的对 象）。
- 终止协程的一种方式：发送某个哨符值，让协程退出。内置的 None 和 Ellipsis 等常量经常用作哨符值。Ellipsis 的优点是，数据流中不太常有这个值。我还见 过有人把 StopIteration 类（类本身，而不是实例，也不抛出）作为哨符值；也就是说， 是像这样使用的：my_coro.send(StopIteration)。
- generator.throw(exc_type\[, exc_value\[, traceback]])：致使生成器在暂停的 yield 表达式处抛出指定的异常。如果生成器处理了抛出的异常， 代码会向前执行到下一个 yield 表达式，而产出的值会成为调用 generator.throw 方法 得到的返回值。如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下 文中。
- generator.close()：致使生成器在暂停的 yield 表达式处抛出 GeneratorExit 异常。如果生成器没有处 理这个异常，或者抛出了 StopIteration 异常（通常是指运行到结尾），调用方不会 报错。如果收到 GeneratorExit 异常，生成器一定不能产出值，否则解释器会抛出 RuntimeError 异常。生成器抛出的其他异常会向上冒泡，传给调用方。
- 如果不管协程如何结束都想做些清理工作，要把协程定义体中相关的代码放入 try/ finally 块中。
```python
class DemoException(Exception): 
	"""为这次演示定义的异常类型。""" 
def demo_finally():
	print('-> coroutine started') 
	try: 
		while True: 
			try: 
				x = yield
			except DemoException: 
				print('*** DemoException handled. Continuing...') 
			else: 
				print('-> coroutine received: {!r}'.format(x))
	finally: 
		print('-> coroutine ending')
```

#### 让协程返回值
![](assets/Pasted%20image%2020220806092732.png)
- 注意，return 表达式的值会偷偷传给调用方，赋值给 StopIteration 异常的一个属性。这样 做有点不合常理，但是能保留生成器对象的常规行为——耗尽时抛出 StopIteration 异常。
![](assets/Pasted%20image%2020220806092929.png)
- yield from 结构会在内部自动捕获 StopIteration 异常。这种处理方式与 for 循环处理 StopIteration 异常的方式一样：循环机制使用用户易于理解的方式处理异 常。对 yield from 结构来说，解释器不仅会捕获 StopIteration 异常，还会把 value 属性 的值变成 yield from 表达式的值。

#### 使用yield from
- 在生成器 gen 中使用 yield from subgen() 时，subgen 会获得控制权，把产出的值传给 gen 的调用方，即调用方可以直接控制 subgen。与此同时，gen 会阻塞，等待 subgen 终止。
- yield from x 表达式对 x 对象所做的第一件事是，调用 iter(x)，从中获取迭代器。因此，x 可以是任何可迭代的对象。
- 可是，如果 yield from 结构唯一的作用是替代产出值的嵌套 for 循环，这个结构很有可 能不会添加到 Python 语言中。yield from 结构的本质作用无法通过简单的可迭代对象说 明，而要发散思维，使用嵌套的生成器。因此，引入 yield from 结构的 PEP 380 才起了 “Syntax for Delegating to a Subgenerator”（“把职责委托给子生成器的句法”）这个标题。
- yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来， 这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加 大量处理异常的样板代码。有了这个结构，协程可以通过以前不可能的方式委托职责。
- 专门的术语：
	- 委派生成器：包含 yield from 表达式的生成器函数。
	- 子生成器：从 yield from 表达式中 部 分 获 取 的 生 成 器。
	- 调用方：调用委派生成器的客户端代码。
![](assets/Pasted%20image%2020220806094717.png)
（注：外层 for 循环重新迭代时会新建一个 grouper 实例，然后绑定到 group 变量上。前一个 grouper 实例（以及它创建的尚未终止的 averager 子生成器实例）被垃圾回收程序回收。）
- grouper 发送的每个值都会经由 yield from 处 理， 通 过 管 道 传 给 averager 实 例。 grouper 会在 yield from 表达式处暂停，等待 averager 实例处理客户端发来的值。 averager 实例运行完毕后，返回的值绑定到 results[key] 上。while 循环会不断创建 averager 实例，处理更多的值。
- 如果子生成器不终止，委派生成器会在 yield from 表达式处永远暂停。如果是这样，程序不会向前执行，因为 yield from （与 yield 一样）把控制权转交给客户代码（即，委派生成器的调用方）了。
- 因为委派生成器相当于管道，所以可以把任意数量个委派生成器连接在一起：一个委派 生成器使用 yield from 调用一个子生成器，而那个子生成器本身也是委派生成器，使用 yield from 调用另一个子生成器，以此类推。最终，这个链条要以一个只使用 yield 表达 式的简单生成器结束；不过，也能以任何可迭代的对象结束。
- 任何 yield from 链条都必须由客户驱动，在最外层委派生成器上调用 next(...) 函数 或 .send(...) 方法。可以隐式调用，例如使用 for 循环。例如： 

#### yield from的意义
- 把迭代器当作生成器使用，相当于把子生成器的定义体内联在 yield from 表达式 中。此外，子生成器可以执行 return 语句，返回一个值，而返回的值会成为 yield from 表达式的值。
- 子生成器产出的值都直接传给委派生成器的调用方（即客户端代码）。
- 使用 send() 方法发给委派生成器的值都直接传给子生成器。如果发送的值是 None，那 么会调用子生成器的 \_\_next__() 方法。如果发送的值不是 None，那么会调用子生成器 的 send() 方法。如果调用的方法抛出 StopIteration 异常，那么委派生成器恢复运行。 任何其他异常都会向上冒泡，传给委派生成器。
- 生成器退出时，生成器（或子生成器）中的 return expr 表达式会触发 StopIteration(expr) 异常抛出。
- yield from 表达式的值是子生成器终止时传给 StopIteration 异常的第一个参数。
- 传入委派生成器的异常，除了 GeneratorExit 之外都传给子生成器的 throw() 方法。如 果调用 throw() 方法时抛出 StopIteration 异常，委派生成器恢复运行。StopIteration 之外的异常会向上冒泡，传给委派生成器。
- 如果把 GeneratorExit 异常传入委派生成器，或者在委派生成器上调用 close() 方法， 那么在子生成器上调用 close() 方法，如果它有的话。如果调用 close() 方法导致异常 抛出，那么异常会向上冒泡，传给委派生成器；否则，委派生成器抛出 GeneratorExit 异常。
- yield from 的具体语义很难理解，尤其是处理异常的那两点。(太难了！！！)

#### 协程
- 协程显式自主地把控制权让步给中央调度程序。而多线 程实现的是抢占式多任务。调度程序可以在任何时刻暂停线程（即使在执行一个语句的过 程中），把控制权让给其他线程。

---
### 第十七章 使用future处理并发
#### 使用concurrent.futures模块
- concurrent.futures 模块的主要特色是 ThreadPoolExecutor 和 ProcessPoolExecutor 类，这 两个类实现的接口能分别在不同的线程或进程中执行可调用的对象。这两个类在内部维护 着一个工作线程或进程池，以及要执行的任务队列。
![](assets/Pasted%20image%2020220806154634.png)
![](assets/Pasted%20image%2020220806154701.png)

#### future 的概念
- future 指一种对象，表示异步执行的操作。这个概念的作 用很大，是 concurrent.futures 模块和 asyncio 包的基础。
- 从 Python 3.4 起， 标 准 库 中 有 两 个 名 为 Future 的 类：concurrent.futures.Future 和 asyncio.Future。这两个类的作用相同：两个 Future 类的实例都表示可能已经完成或者尚 未完成的延迟计算。这与 Twisted 引擎中的 Deferred 类、Tornado 框架中的 Future 类，以 及多个 JavaScript 库中的 Promise 对象类似。
- future 封装待完成的操作，可以放入队列，完成的状态可以查询，得到结果（或抛出异常） 后可以获取结果（或异常）。
- 我们要记住一件事：通常情况下自己不应该创建 future，而只能由并发框架（concurrent. futures 或 asyncio）实例化。原因很简单：future 表示终将发生的事情，而确定某件事 会发生的唯一方式是执行的时间已经排定。因此，只有排定把某件事交给 concurrent. futures.Executor 子 类 处 理 时， 才 会 创 建 concurrent.futures.Future 实 例。 例 如， Executor.submit() 方法的参数是一个可调用的对象，调用这个方法后会为传入的可调用对 象排期，并返回一个 future。
- 客户端代码不应该改变 future 的状态，并发框架在 future 表示的延迟计算结束后会改变 future 的状态，而我们无法控制计算何时结束。
- 这两种 future 都有 .done() 方法，这个方法不阻塞，返回值是布尔值，指明 future 链接的 可调用对象是否已经执行。客户端代码通常不会询问 future 是否运行结束，而是会等待通 知。因此，两个 Future 类都有 .add_done_callback() 方法：这个方法只有一个参数，类型是可调用的对象，future 运行结束后会调用指定的可调用对象。
- 此外，还有 .result() 方法。在 future 运行结束后调用的话，这个方法在两个 Future 类 中的作用相同：返回可调用对象的结果，或者重新抛出执行可调用的对象时抛出的异常。
- 可是，如果 future 没有运行结束，result 方法在两个 Future 类中的行为相差很大。对 concurrency.futures.Future 实例来说，调用 f.result() 方法会阻塞调用方所在的线程， 直到有结果可返回。此时，result 方法可以接收可选的 timeout 参数，如果在指定的时 间内 future 没有运行完毕，会抛出 TimeoutError 异常。asyncio. Future.result 方法不支持设定超时时间，在那个库中获取 future 的结果最好使用 yield from 结构。不过，对 concurrency.futures.Future 实例不能这么做。
- 这两个库中有几个函数会返回 future，其他函数则使用 future，以用户易于理解的方式实现自 身。Executor.map 方法属于后者：返回值是一个迭代器，迭代器的 \_\_next__ 方 法调用各个 future 的 result 方法，因此我们得到的是各个 future 的结果，而非 future 本身（看源码，比较简单！）。
- 为了从实用的角度理解 future，我们可以使用 concurrent.futures.as_completed 函数重写 示例。这个函数的参数是一个 future 列表，返回值是一个迭代器，在 future 运行结束 后产出 future。修 改 download_many 函 数， 把 较 抽 象 的 executor.map 调用换成两个 for 循环：一个用于创建并排定 future，另一个用于获取 future 的结果。
![](assets/Pasted%20image%2020220806162758.png)
注意，在这个示例中调用 future.result() 方法绝不会阻塞，因为 future 由 as_completed 函数产出。（as_completed返回的是一个迭代器，迭代获取future是会阻塞，所以获取到的future都是finished的）
![](assets/Pasted%20image%2020220811223221.png)

#### 阻塞型I/O和GIL
- CPython 解释器本身就不是线程安全的，因此有全局解释器锁（GIL），一次只允许使用一 个线程执行 Python 字节码。因此，一个 Python 进程通常不能同时使用多个 CPU 核心。
- 这是 CPython 解释器的局限，与 Python 语言本身无关。Jython 和 IronPython 没有这种限制。不过， 目前最快的 Python 解释器 PyPy 也有 GIL。
- 编写 Python 代码时无法控制 GIL；不过，执行耗时的任务时，可以使用一个内置的函数 或一个使用 C 语言编写的扩展释放 GIL。
- 然而，标准库中所有执行阻塞型 I/O 操作的函数，在等待操作系统返回结果时都会释放 GIL。这意味着在 Python 语言这个层次上可以使用多线程，而 I/O 密集型 Python 程序能从 中受益：一个 Python 线程等待网络响应时，阻塞型 I/O 函数会释放 GIL，再运行一个线程。

#### 使用concurrent.futures模块启动进程
- 使用 ProcessPoolExecutor 类把工作分配给多个 Python 进程处理。因此，如果需要 做 CPU 密集型处理，使用这个模块能绕开 GIL，利用所有可用的 CPU 核心。
- ProcessPoolExecutor 和 ThreadPoolExecutor 类都实现了通用的 Executor 接口，因此使用 concurrent.futures 模块能特别轻松地把基于线程的方案转成基于进程的方案。
- 这两个实现 Executor 接口的类唯一值得注意的区别是，ThreadPool Executor.\_\_init__ 方法需要 max_workers 参 数， 指 定 线 程 池 中 线 程 的 数 量。 在 ProcessPoolExecutor 类中，那个参数是可选的，而且大多数情况下不使用——默认值是 os.cpu_count() 函数返回的 CPU 数量。
- Executor.map函数返回结果的顺序与调用开始的顺序一致。如果第一个调用生成结果用时 10 秒，而其他调用只用 1 秒，代码会阻塞 10 秒，获取 map 方法返回的生成器产出的第一个 结果。在此之后，获取后续结果时不会阻塞，因为后续的调用已经结束。如果必须等到获 取所有结果后再处理，这种行为没问题；不过，通常更可取的方式是，不管提交的顺序， 只要有结果就获取。为此，要把 Executor.submit 方法和 futures.as_completed 函数结合 起来使用。
- executor.submit 和 futures.as_completed 这个组合比 executor.map 更灵活， 因为 submit 方法能处理不同的可调用对象和参数，而 executor.map 只能处 理参数不同的同一个可调用对象。此外，传给 futures.as_completed 函数的 future 集合可以来自多个 Executor 实例，例如一些由 ThreadPoolExecutor 实 例创建，另一些由 ProcessPoolExecutor 实例创建。

---
### 第十八章 使用asyncio包处理并发
#### asyncio 
这个包使用事件循环驱动的协程实现并发。这是 Python 中最大也 是最具雄心壮志的库之一。

#### @asyncio.coroutine 装饰器
- asyncio 包使用的“协程”是较严格的定义。适合 asyncio API 的协程在定义体中必须使用 yield from，而不能使用 yield。
- 此 外，适合 asyncio 的协程要由调用方驱动，并由调用方通过 yield from 调用； 或者把协程传给 asyncio 包中的某个函数，例如 asyncio.async(...) 和本章 要介绍的其他函数，从而驱动协程。
- 最后，@asyncio.coroutine 装饰器应该应 用在协程上。

#### TODO

---
### 第十九章 动态属性和特性
#### 使用动态属性访问JSON类数据
```python
from collections import abc 
class FrozenJSON:
	"""一个只读接口，使用属性表示法访问JSON类对象 """ 
	def __init__(self, mapping): 
		self.__data = dict(mapping)
		
	def __getattr__(self, name):  
		if hasattr(self.__data, name): 
			return getattr(self.__data, name) 
		else: 
			return FrozenJSON.build(self.__data[name])
			
	@classmethod 
	def build(cls, obj):  
		if isinstance(obj, abc.Mapping):  
			return cls(obj) 
		elif isinstance(obj, abc.MutableSequence):  
			return [cls.build(item) for item in obj] 
		else:  
			return obj
```
- FrozenJSON 类有个缺陷：没有对名称为 Python 关键字的属性做特殊处理。

#### 使用__new__方法以灵活的方式创建对象
- 我们通常把 \_\_init__ 称为构造方法，这是从其他语言借鉴过来的术语。其实，用于构建实 例的是特殊方法 \_\_new__：这是个类方法（使用特殊方式处理，因此不必使用 @classmethod 装饰器），必须返回一个实例。返回的实例会作为第一个参数（即 self）传给 \_\_init__ 方 法。因为调用 \_\_init__ 方法时要传入实例，而且禁止返回任何值，所以 \_\_init__ 方法其实是“初始化方法”。真正的构造方法是 \_\_new__。我们几乎不需要自己编写 \_\_new__ 方法， 因为从 object 类继承的实现已经足够了。
- \_\_new__ 方法也可以返回其他类的实例，此时，解释器不会调用 \_\_init__ 方法。
- 也就是说，Python 构建对象的过程可以使用下述伪代码概括：
![](assets/Pasted%20image%2020220807000719.png)
- 使用 \_\_new__ 方法取代 build 方法，构建可能是也可能不是 FrozenJSON 实例的新对象:
![](assets/Pasted%20image%2020220807000926.png)
- 对象的 \_\_dict__ 属性中 存储着对象的属性——前提是类中没有声明 \_\_slots__ 属性。因此，更新 实例的 \_\_dict__ 属性，把值设为一个映射，能快速地在那个实例中创建一堆属性。

#### 特性全解析
- 特性是是覆盖型描述符。
- 虽然内置的 property 经常用作装饰器，但它其实是一个类。
- property 构造方法的完整签名如下：
```python
property(fget=None, fset=None, fdel=None, doc=None)
```
所有参数都是可选的，如果没有把函数传给某个参数，那么得到的特性对象就不允许执行 相应的操作。

#### 特性会覆盖实例属性
- 特性都是类属性，但是特性管理的其实是实例属性的存取。
- 如果实例和所属的类有同名数据属性，那么实例属性会覆盖（或称遮盖）类 属性——至少通过那个实例读取属性时是这样。
- 实例属性不会遮盖类特性。
- obj.attr 这样的表达式不会从 obj 开始寻找 attr，而是从 obj.__ class__ 开始，而且，仅当类中没有名为 attr 的特性时，Python 才会在 obj 实例中寻 找。这条规则不仅适用于特性，还适用于一整类描述符——覆盖型描述符（overriding descriptor）。
- 直接存取 \_\_dict__ 属性能跳过特性的处理逻辑。
![](assets/Pasted%20image%2020220807080937.png)

#### 定义一个特性工厂函数
![](assets/Pasted%20image%2020220807082858.png)
![](assets/Pasted%20image%2020220807082935.png)

#### 影响属性处理方式的特殊属性
后面几节中的很多函数和特殊方法，其行为受下述 3 个特殊属性的影响：
- \_\_class__：对象所属类的引用（即 obj.\_\_class__ 与 type(obj) 的作用相同）。Python 的某些特殊方法，例如 \_\_getattr__，只在对象的类中寻找，而不在实例中寻找。
- \_\_dict__：一个映射，存储对象或类的可写属性。有 \_\_dict__ 属性的对象，任何时候都能随意设 置新属性。如果类有 \_\_slots__ 属性，它的实例可能没有 \_\_dict__ 属性。参见下面对 \_\_slots__ 属性的说明。
- \_\_slots__：类可以定义这个这属性，限制实例能有哪些属性。\_\_slots__ 属性的值是一个字符串组 成的元组，指明允许有的属性。如果 \_\_slots__ 中没有 '\_\_dict__'，那么该类的实例 没有 \_\_dict__ 属性，实例只允许有指定名称的属性。

#### 处理属性的内置函数
下述 5 个内置函数对对象的属性做读、写和内省操作：
- dir(\[object])：列出对象的大多数属性。官方文档（https://docs.python.org/3/library/functions.html#dir） 说，dir 函数的目的是交互式使用，因此没有提供完整的属性列表，只列出一组“重 要的”属性名。dir 函数能审查有或没有 \_\_dict__ 属性的对象。dir 函数不会列出 \_\_dict__ 属性本身，但会列出其中的键。dir 函数也不会列出类的几个特殊属性，例如 \_\_mro__、\_\_bases__ 和 \_\_name__。如果没有指定可选的 object 参数，dir 函数会列出当 前作用域中的名称。
- getattr(object, name\[, default])：从 object 对象中获取 name 字符串对应的属性。获取的属性可能来自对象所属的类或超 类。如果没有指定的属性，getattr 函数抛出 AttributeError 异常，或者返回 default 参数的值（如果设定了这个参数的话）。
- hasattr(object, name)：如果 object 对象中存在指定的属性，或者能以某种方式（例如继承）通过 object 对 象 获 取 指 定 的 属 性， 返 回 True。 文 档（https://docs.python.org/3/library/functions. html#hasattr）说道：“这个函数的实现方法是调用 getattr(object, name) 函数，看看是 否抛出 AttributeError 异常。”
- setattr(object, name, value)：把 object 对象指定属性的值设为 value，前提是 object 对象能接受那个值。这个函数 可能会创建一个新属性，或者覆盖现有的属性。
- vars(\[object])：返回 object 对象的 \_\_dict__ 属性；如果实例所属的类定义了 \_\_slots__ 属性，实例没 有 \_\_dict__ 属性，那么 vars 函数不能处理那个实例（相反，dir 函数能处理这样的实 例）。如果没有指定参数，那么 vars() 函数的作用与 locals() 函数一样：返回表示本 地作用域的字典。

#### 处理属性的特殊方法
- 在用户自己定义的类中，下述特殊方法用于获取、设置、删除和列出属性。 
- 使用点号或内置的 getattr、hasattr 和 setattr 函数存取属性都会触发下述列表中相应的 特殊方法。但是，直接通过实例的 \_\_dict__ 属性读写属性不会触发这些特殊方法——如果 需要，通常会使用这种方式跳过特殊方法。
- 对用户自己定义的类来说，如果隐式调用特殊方法，仅当特殊方法在对象所属的类 型上定义，而不是在对象的实例字典中定义时，才能确保调用成功。
- 特殊方法 不会被同名实例属性遮盖。
- obj.attr 和 getattr(obj, 'attr', 42) 都会触发 Class. \_\_getattribute__(obj, 'attr') 方法。

- \_\_delattr__(self, name)：只要使用 del 语句删除属性，就会调用这个方法。例如，del obj.attr 语句触发 Class.\_\_delattr__(obj, 'attr') 方法。
- \_\_dir__(self)：把对象传给 dir 函数时调用，列出属性。例如，dir(obj) 触发 Class.\_\_dir__(obj) 方法。
- \_\_getattr__(self, name)：仅当获取指定的属性失败，搜索过 obj、Class 和超类之后调用。表达式 obj.no_such_ attr、getattr(obj, 'no_such_attr') 和 hasattr(obj, 'no_such_attr') 可能会触发 Class.\_\_getattr__(obj, 'no_such_attr') 方法，但是，仅当在 obj、Class 和超类中找 不到指定的属性时才会触发。
- \_\_getattribute__(self, name)：尝试获取指定的属性时总会调用这个方法，不过，寻找的属性是特殊属性或特殊方法 时除外。点号与 getattr 和 hasattr 内置函数会触发这个方法。调用 \_\_getattribute__方法且抛出 AttributeError 异常时，才会调用 \_\_getattr__ 方法。为了在获取 obj 实例的属性时不导致无限递归，\_\_getattribute__ 方法的实现要使用 super().__ getattribute__(obj, name)。
- \_\_setattr__(self, name, value)：尝试设置指定的属性时总会调用这个方法。点号和 setattr 内置函数会触发这个方法。 例如，obj.attr = 42 和 setattr(obj, 'attr', 42) 都会触发 Class.\_\_setattr__(obj, ‘attr’, 42) 方法。
- 其实，特殊方法 \_\_getattribute__ 和 \_\_setattr__ 不管怎样都会调用，几 乎会影响每一次属性存取，因此比 \_\_getattr__ 方法（只处理不存在的属性 名）更难正确使用。与定义这些特殊方法相比，使用特性或描述符相对不易 出错。

---
### 第二十章 属性描述符
#### 描述符
- 描述符是对多个属性运用相同存取逻辑的一种方式。
- 描述符是实现了特定协议的类，这个协议包括 \_\_get__、\_\_set__ 和 \_\_delete__ 方法。
- property 类实现了完整的描述符协议。
- 通常，可以只实现部分协议。
- 除了 特性之外，使用描述符的 Python 功能还有方法及 classmethod 和 staticmethod 装饰器。
- 描述符的用法是，创建一个实 例，作为另一个类的类属性。
![](assets/Pasted%20image%2020220807094502.png)
**描述符实例声明为托管类的类属性**（Quantity 实例是 LineItem 类的类属性）

![](assets/Pasted%20image%2020220807111406.png)
Quantity 实例是描述符，因此有个放大镜，用于获 取值（\_\_get__），以及一个手抓，用于设置值（\_\_set__）。
![](assets/Pasted%20image%2020220807111427.png)

#### 描述符示例：验证属性
![](assets/Pasted%20image%2020220807142251.png)
![](assets/Pasted%20image%2020220807142318.png)
- 在示例 20-1 中，各个托管属性的名称与储存属性一样，而且读值方法不需要特殊的逻辑， 所以 Quantity 类不需要定义 \_\_get__ 方法。
- 示例 20-1 有个缺点，在托管类的定义体中实例化描述符时要重复输入属性的名称。
- 为了避免在描述符声明语句中重复输入属性名，我们将为每个 Quantity 实例的 storage_ name 属性生成一个独一无二的字符串。
- 在前缀中使用井号能避免 storage_name 与用户使用点号创建的属性冲 突，因为 nutmeg.\_Quantity#0 是无效的 Python 句法。但是，内置的 getattr 和 setattr 函数可以使用这种“无效的”标识符获取和设置属性，此外也可以直接处理实例属性 \_\_dict__。
![](assets/Pasted%20image%2020220807142822.png)
![](assets/Pasted%20image%2020220807142849.png)
- 注 意，\_\_get__ 方 法 有 三 个 参 数：self、instance 和 owner。owner 参 数 是 托 管 类（ 如 LineItem）的引用，通过描述符从托管类中获取属性时用得到。
- 这里可以使用内置的高阶函数 getattr 和 setattr 存取值，无需使用 instance.\_\_dict__， 因为托管属性和储存属性的名称不同，所以把储存属性传给 getattr 函数不会触发描述符， 不会像示例 20-1 那样出现无限递归。
- 如果使用 LineItem.weight 从类中获取托管属性（以 weight 为例），描述符的 \_\_get__ 方法接收到的 instance 参数值 是 None。因此，会抛出 AttributeError 异常。
- 为了给用户提供内省和其他元编程技术支持，通过类访问托管属性时，最好让 \_\_get__ 方法返回描述符实例。
- 描述符在类中定义，因此可以利用继承重用部分代码来创建新描述符。
- 以上所举的几个 LineItem 示例演示了描述符的典型用途——管理数据属性。这种描述符也叫 覆盖型描述符，因为描述符的 \_\_set__ 方法使用托管实例中的同名属性覆盖（即插手接管） 了要设置的属性。

#### 覆盖型与非覆盖型描述符对比
- Python 存取属性的方式特别不对等。通过实例读取属性时，通常返回的是实例 中定义的属性；但是，如果实例中没有指定的属性，那么会获取类属性。而为实例中的属性赋值时，通常会在实例中创建属性，根本不影响类。
- 这种不对等的处理方式对描述符也有影响。其实，根据是否定义 \_\_set__ 方法，描述符可 分为两大类。
- （搞清楚谁覆盖谁：描述符的行为会不会被覆盖 ==覆盖== 是相对实例对象属性和类对象属性来说的，对于一个实例对象来说，如果它的类对象中有同名的覆盖型描述符属性，那么实例对象的这个属性就会被同名的类对象的属性描述符属性覆盖）
- 覆盖型描述符也叫数 据描述符或强制描述符。非覆盖型描述符也叫非数据描述符或遮盖型描述符。
- 分析对 Managed 类及其实例做属性读写时的行为：
![](assets/Pasted%20image%2020220807152219.png)
![](assets/Pasted%20image%2020220807152337.png)
- **覆盖型描述符**	
	- 实现 \_\_set__ 方法的描述符属于覆盖型描述符，因为虽然描述符是类属性，但是实现 \_\_set__ 方法的话，会覆盖对实例属性的赋值操作。
	- 特 性也是覆盖型描述符：如果没提供设值函数，property 类中的 \_\_set__ 方法会抛出 AttributeError 异常，指明那个属性是只读的。
	![](assets/Pasted%20image%2020220807152809.png)
![](assets/Pasted%20image%2020220807152852.png)
- **没有__get__方法的覆盖型描述符**
	- 通常，覆盖型描述符既会实现 \_\_set__ 方法，也会实现 \_\_get__ 方法，不过也可以只实 现 \_\_set__ 方法。
	- 此时，只有写操作由描述符处理。通过实例读取描 述符会返回描述符对象本身，因为没有处理读操作的 \_\_get__ 方法。
	- 如果直接通过实例的 \_\_dict__ 属性创建同名实例属性，以后再设置那个属性时，仍会由 \_\_set__ 方法插手接管， 但是读取那个属性的话，就会直接从实例中返回新赋予的值，而不会返回描述符对象。
	![](assets/Pasted%20image%2020220807154216.png)
	![](assets/Pasted%20image%2020220807154259.png)
- **非覆盖型描述符**
	- 没有实现 \_\_set__ 方法的描述符是非覆盖型描述符。
	- 如果设置了同名的实例属性，描述符 会被遮盖，致使描述符无法处理那个实例的那个属性。
	- 方法是以非覆盖型描述符实现的。
	![](assets/Pasted%20image%2020220807161504.png)
- 不管描述符是不是覆盖型，为类属性赋值都能覆盖描述符。
![](assets/Pasted%20image%2020220807161809.png)
- 示例 20-12 揭示了读写属性的另一种不对等：读类属性的操作可以由依附在托管类上定义 有 、\_\_get__ 方法的描述符处理，但是写类属性的操作不会由依附在托管类上定义有 \_\_set__ 方法的描述符处理。
- 若想控制设置类属性的操作，要把描述符依附在类的类上，即依附在元类上。 默认情况下，对用户定义的类来说，其元类是 type，而我们不能为 type 添 加属性。

#### 方法是描述符
- 在类中定义的函数属于绑定方法（bound method），因为用户定义的函数都有 __get__ 方法，所以依附到类上时，就相当于描述符。
![](assets/Pasted%20image%2020220807162544.png)
- 函数没有实现 \_\_set__ 方法，因此是非覆盖型描述符。
- 从示例 20-13 中还可以看出一个重要信息：obj.spam 和 Managed.spam 获取的是不同的对 象。与描述符一样，通过托管类访问时，函数的 \_\_get__ 方法会返回自身的引用。但是， 通过实例访问时，函数的 \_\_get__ 方法返回的是绑定方法对象：一种可调用的对象，里 面包装着函数，并把托管实例（例如 obj）绑定给函数的第一个参数（即 self），这与 functools.partial 函数的行为一致。
- 为了深入理解这种机制，请看示例 20-14：
![](assets/Pasted%20image%2020220807164216.png)
![](assets/Pasted%20image%2020220807164233.png)
- 绑定方法对象还有个 \_\_call__ 方法，用于处理真正的调用过程。这个方法会调用 \_\_func__ 属性引用的原始函数，把函数的第一个参数设为绑定方法的 \_\_self__ 属性。这就是形参 self 的隐式绑定方式。

#### 描述符用法建议
- 使用特性以保持简单：内置的 property 类创建的其实是覆盖型描述符，\_\_set__ 方法和 \_\_get__ 方法都实现 了，即便不定义设值方法也是如此。特性的 \_\_set__ 方法默认抛出 AttributeError: can't set attribute，因此创建只读属性最简单的方式是使用特性，这能避免下一条所 述的问题。
- 只读描述符必须有 \_\_set__ 方法：如果使用描述符类实现只读属性，要记住，\_\_get__ 和 \_\_set__ 两个方法必须都 定义，否则，实例的同名属性会遮盖描述符。只读属性的 \_\_set__ 方法只需抛出 AttributeError 异常，并提供合适的错误消息。
- 用于验证的描述符可以只有 \_\_set__ 方法：对仅用于验证的描述符来说，\_\_set__ 方法应该检查 value 参数获得的值，如果有效， 使用描述符实例的名称为键，直接在实例的 \_\_dict__ 属性中设置。这样，从实例中读 取同名属性的速度很快，因为不用经过 \_\_get__ 方法处理。
- 仅有 \_\_get__ 方法的描述符可以实现高效缓存：如果只编写了 \_\_get__ 方法，那么创建的是非覆盖型描述符。这种描述符可用于执行 某些耗费资源的计算，然后为实例设置同名属性，缓存结果。同名实例属性会遮盖描述符，因此后续访问会直接从实例的 \_\_dict__ 属性中获取值，而不会再触发描述符的 \_\_get__ 方法。
- 非特殊的方法可以被实例属性遮盖：由于函数和方法只实现了 \_\_get__ 方法，它们不会处理同名实例属性的赋值操作。因 此，像 my_obj.the_method = 7 这样简单赋值之后，后续通过该实例访问 the_method 得到的是数字 7——但是不影响类或其他实例。然而，特殊方法不受这个问题的影响。 解释器只会在类中寻找特殊的方法，也就是说，repr(x) 执行的其实是 x.\_\_class__. \_\_repr__(x)，因此 x 的 \_\_repr__ 属性对 repr(x) 方法调用没有影响。出于同样的原因， 实例的 \_\_getattr__ 属性不会破坏常规的属性访问规则。

#### 描述符的文档字符串和覆盖删除操作
- 描述符类的文档字符串用于注解托管类中的各个描述符实例。
- 提供的信息有点不足。对 LineItem 类来说，如果能说明 weight 必须以千克为单位就好了。 这对特性来说是小菜一碟，因为各个特性只处理特定的托管属性。可是对描述符来说， weight 和 price 使用的都是 Quantity 描述符类。

---
### 第二十一章 类元编程
- 类元编程是指在运行时创建或定制类的技艺。
- 在 Python 中，类是一等对象，因此任何时候 都可以使用函数新建类，而无需使用 class 关键字。
- 类装饰器也是函数，不过能够审查、 修改，甚至把被装饰的类替换成其他类。
- 最后，元类是类元编程最高级的工具：使用元类 可以创建具有某种特质的全新类种，例如我们见过的抽象基类。

#### 类工厂函数
- 标准库中的一个类工厂函数——collections.namedtuple。我们把一个类名 和几个属性名传给这个函数，它会创建一个 tuple 的子类，其中的元素通过名称获取，还 为调试提供了友好的字符串表示形式（\_\_repr__）。
- 参考 collections.namedtuple，下面我们创建一个 record_factory 函数，即时创建简单的 类（如 Dog）。
![](assets/Pasted%20image%2020220807183316.png)
![](assets/Pasted%20image%2020220807183945.png)
- 通常，我们把 type 视作函数，因为我们像函数那样使用它，例如，调用 type(my_object) 获取对象所属的类——作用与 my_object.\_\_class__ 相同。然而，type 是一个类。当成类 使用时，传入三个参数可以新建一个类：
```python
MyClass = type('MyClass', (MySuperClass, MyMixin), {'x': 42, 'x2': lambda self: self.x * 2})
```
type 的三个参数分别是 name、bases 和 dict。最后一个参数是一个映射，指定新类的属性 名和值。
- 把三个参数传给 type 是动态创建类的常用方式。如果查看 collections.namedtuple 函数 的 源 码（https://hg.python.org/cpython/file/3.4/Lib/collections/\_\_init__.py#l236）， 你 会 发 现 另一种方式：先声明一个 \_class_template 变量，其值是字符串形式的源码模板；然后在 namedtuple 函数中调用 \_class_template.format(...) 方法，填充模板里的空白；最后，使 用内置的 exec 函数计算得到的源码字符串。
- record_factory 函数创建的类，其实例有个局限——不能序列化，即不能使用 pickle 模 块里的 dump/load 函数处理。这个示例是为了说明如何使用 type 类满足简单的需求，因此 不会解决这个问题。如果想了解完整的方案，请分析 collections.nameduple 函数的源码 （https://hg.python.org/cpython/file/3.4/Lib/collections/\_\_init__.py#l236）， 搜 索“pickling” 这 个词。

####  类装饰器
- 类装饰器与函数装饰器非常类似，是参数为类对象的函数，返回原来的类或修改后的类。
![](assets/Pasted%20image%2020220807192619.png)
- 类装饰器能以较简单的方式做到以前需要使用元类去做的事 情——创建类时定制类。
- 类装饰器有个重大缺点：只对直接依附的类有效。这意味着，被装饰的类的子类可能继承 也可能不继承装饰器所做的改动，具体情况视改动的方式而定。

#### 导入时和运行时比较
- Python 程序 员会区分“导入时”和“运行时”，不过这两个术语没有严格的定义，而且二者之间存在 着灰色地带。
- 在导入时，解释器会从上到下一次性解析完 .py 模块的源码，然后生成用于 执行的字节码。如果句法有错误，就在此时报告。如果本地的 \_\_pycache__ 文件夹中有最 新的 .pyc 文件，解释器会跳过上述步骤，因为已经有运行所需的字节码了。
- 编译肯定是导入时的活动，不过那个时期还会做些其他事，因为 Python 中的语句几乎都 是可执行的，也就是说语句可能会运行用户代码，修改用户程序的状态。
- 尤其是 import 语句，它不只是声明 ，在进程中首次导入模块时，还会运行所导入模块中的全部顶层代 码——以后导入相同的模块则使用缓存，只做名称绑定。
- 那些顶层代码可以做任何事，包 括通常在“运行时”做的事，例如连接数据库。因此，“导入时”与“运行时”之间的界 线是模糊的：import 语句可以触发任何“运行时”行为。
- 导入模块时，解释器会执行顶层的 def 语句，会编译函数的定义体（首次导入模块时），把函数对象绑定到对应的全局名称上，但是显然解释器 不会执行函数的定义体。
- 通常这意味着解释器在导入时定义顶层函数，但是仅当在运行时 调用函数时才会执行函数的定义体。
- 对类来说，情况就不同了：在导入时，解释器会执行每个类的定义体，甚至会执行嵌套类 的定义体。
- 执行类定义体的结果是，定义了类的属性和方法，并构建了类对象。
- 从这个意 义上理解，类的定义体属于“顶层代码”，因为它在导入时运行。
- 与此不同的是，如果想定制整个类层次结构，而不是一次只定制一个类，使用下一节介绍 的元类更高效。

#### 元类基础知识
- 元类是制造类的工厂，不过不是函数，而是类。
- 默认情况下，Python 中的类是 type 类的实例。也就是说，type 是大多数内置的类和用户定义的类的元类。
- 为了避免无限回溯，type 是其自身的实例。
![](assets/Pasted%20image%2020220807195833.png)
- object 类和 type 类之间的关系很独特：object 是 type 的实例，而 type 是 object 的子类。这种关系很“神奇”，无法使用 Python 代码表述，因为定义其 中一个之前另一个必须存在。type 是自身的实例这一点也很神奇。
- 除了 type，标准库中还有一些别的元类，例如 ABCMeta 和 Enum。
- collections.Iterable 所属的类是 abc.ABCMeta。Iterable 是抽象类，而 ABCMeta 不是—— 不管怎样，Iterable 是 ABCMeta 的实例。
- 向上追溯，ABCMeta 最终所属的类也是 type。所有类都直接或间接地是 type 的实例，不 过只有元类同时也是 type 的子类。
- 元类（如 ABCMeta）从 type 类继承了构建类的能力。
![](assets/Pasted%20image%2020220807200428.png)
- 元类可以通过实现 \_\_init__ 方法定制实例。元类的 \_\_init__ 方法可以做到类装饰器能做的任何事情，但是作用更大。
- 编写元类时，通常会把 self 参数改成 cls。例如，在元类的 \_\_init__ 方 法中，把第一个参数命名为 cls 能清楚地表明要构建的实例是类。
- 如果想进一步定制类，可以在元类中实现 \_\_new__ 方法。不过，通常情况下实 现 \_\_init__ 方法就够了。

#### 定制描述符的元类
![](assets/Pasted%20image%2020220807220523.png)
![](assets/Pasted%20image%2020220807220836.png)
![](assets/Pasted%20image%2020220807223138.png)

#### 元类的特殊方法__prepare__
- 在某些应用中，可能需要知道类的属性定义的顺序。type 构造方法及元类的 \_\_new__ 和 \_\_init__ 方法都会收到要计算的类的定义 体，形式是名称到属性的映像。然而在默认情况下，那个映射是字典；也就是说，元类或 类装饰器获得映射时，属性在类定义体中的顺序已经丢失了。
- 这个问题的解决办法是，使用 Python 3 引入的特殊方法 \_\_prepare__。这个特殊方法只在 元类中有用，而且必须声明为类方法（即，要使用 @classmethod 装饰器定义）。解释器调 用元类的 \_\_new__ 方法之前会先调用 \_\_prepare__ 方法，使用类定义体中的属性创建映射。
- \_\_prepare__ 方法的第一个参数是元类，随后两个参数分别是要构建的类的名称和基类组 成的元组，返回值必须是映射。元类构建新类时，\_\_prepare__ 方法返回的映射会传给 \_\_new__ 方法的最后一个参数，然后再传给 \_\_init__ 方法。

#### 类作为对象
- cls.\_\_bases__：由类的基类组成的元组。
- cls.\_\_qualname__：Python 3.3 新引入的属性，其值是类或函数的限定名称，即从模块的全局作用域到类的 点分路径。例如，在示例 21-6 中，内部类 ClassTwo 的 \_\_qualname__ 属性，其值是字符 串 'ClassOne.ClassTwo'，而 \_\_name__ 属性的值是 'ClassTwo'。
- cls.\_\_subclasses__() 这个方法返回一个列表，包含类的直接子类。这个方法的实现使用弱引用，防止在超类 和子类（子类在 \_\_bases__ 属性中储存指向超类的强引用）之间出现循环引用。这个方 法返回的列表中是内存里现存的子类。
- cls.mro() 构建类时，如果需要获取储存在类属性 \_\_mro__ 中的超类元组，解释器会调用这个方 法。元类可以覆盖这个方法，定制要构建的类解析方法的顺序。
![](assets/Pasted%20image%2020220807225705.png)


[[Fluent Python 2E]]
