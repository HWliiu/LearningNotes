### 第一章 基本数据与表达式

#### 程序的编译执行

把一个.cpp 文件编译成.exe 目标文件，要经过预处理、编译和连接 3 个步骤：预处理的作用是执行程序编译之前的准备，例如执行包含指令、宏替换命令；然后编译器对程序进行语法检查，如果发现语法错误，则显示错误信息，让程序员修改，直至正确，生成目标代码；最后把目标代码进行连接处理，往往还会加入一些系统提供的库文件代码。

#### C++语言常用的关键字

array bool break case catch char class const continue default delete do double else enum extern false float for friend goto if inline int long namespace new nullptr operator private protected public return short sizeof static struct switch template this throw true try typedef typename union unsigned virtual void while

#### C++语言的数据类型

![](assets/2023-04-19-23-02-57.png)
空类型不是值意义可以直接解释的数据类型，它用于表示函数无返回值，或指针所指对象无结构。此时需要通过强类型转换才能解释数据。

#### c++语言基本数据类型

![](assets/2023-04-19-23-15-48.png)
系统在内存存放字符串时，除了每个符号占一个字节外，还自动添加一个空字符'\0'作为串结束标志。所以，字符'x'和字符串"x"的数据类型和存储形式不一样。

#### 访问变量

内存单元由操作系统按字节编号，称为地址。当程序出现常量或变量说明语句时，编译器按类型分配存储空间，把地址写入标识符表。标识符就是获得分配的内存单元的名字。
一个指针变量如果仅作说明而不赋值，则它的值是不确定及无意义的。

#### 引用

引用说明为对象建立引用名，即别名。\&的意义是在定义时与对象名绑定，程序中不能对引用重定义。一个对象的别名，在使用方式和效果上，与使用对象名一致。引用仅仅是对象的别名，不开辟新的内存空间。这与对象指针不同。引用常常用于函数参数的传递。

#### 指向常量的指针

用 const 约束指针对所指对象访问时，这个指针称为指向常量的指针。定义形式：
**const 类型 \* 指针** 或者 **类型 const \* 指针**
c++语言为了保证标识常量的只读性，常量的地址只能赋给指向常量的指针。

#### 指针常量

指针常量的意义是指针变量的值只能在定义的时候初始化，定义后不能修改，即不能改变指针变量的指向。但不影响所指对象的访问特性。
指针常量的定义形式为：
**类型 \* const 指针**

#### 指向常量的指针常量

指向常量的指针常量的定义形式为：
**const 类型 \* const 指针** 或者 **类型 const \* const 指针**

#### 常引用

冠以 const 定义的引用，将约束对象用别名方式访问时为只读。常引用的定义形式为：
**const 类型 & 引用名 = 对象名**

#### 运算符

![](assets/2023-04-20-22-07-52.png)

#### 赋值表达式

(a = b) = 10 首先应执行 a=b ， 把 b 的值写入 a，表达式的值确定于 a, 然后执行 a = 10。上式对 a 做了两次写操作， 对 b 做了一次读操作。

#### 逗号表达式

逗号表达式有两层含义：第一，各表达式按顺序执行；第二，逗号表达式也表达一个值，这个值是最后一个表达式的值。

#### 输入输出

![](assets/2023-04-20-20-12-56.png)

---

### 第二章 程序控制结构

#### 赋值表达式用于判断

赋值表达式的值是被赋值变量的值，用于判断表达式中，首先完成赋值运算，然后以被赋值变量的值进行判断。

---

### 第三章 函数

#### 函数原型

- 函数原型是函数的声明，作用是告诉编译器有关函数接口的信息：函数的名字、函数返回值的数据类型、函数的参数个数、参数类型和参数的顺序，编译器根据函数原型检查函数调用的正确性。
- 由于函数原型没有实现代码，因此不需要参数名。这时，函数定义就具有函数原型的作用。

#### 函数参数的传递

C++语言有三种参数传递机制：值传递（值调用）、指针传递（地址调用）和引用传递（引用调用 ）。实际参数和形式参数按照不同传递机制进行通信。

#### 实际参数求值的副作用

- C++没有规定在函数调用时实际参数的求值顺序。实际参数求值顺序的不同规定，对一般参数没有什么影响，但若实际参数表达式之间有求值关联，则同一个程序在不同编译器可能产生不同的运行结果。
- cout << add(++x，x+y） << endl;
- 对于自左向右求实际参数的值的编译系统，首先计算 ++x，然后计算表达式 x+y
- 但对于自右向左求实际参数的值的编译系统，首先计算 x+y，然后计算++x

#### 默认参数

有关默认参数的说明如下：

- C++规定，函数的形式参数说明中设置一个或多个实际参数的默认值， 默认参数必须是函数参数表中最右边（尾部）的参数。调用具有多个默认参数的函数时，如果省略的参数不是参数表中最右边的参数，则该参数右边的所有参数也应该省略。
- 默认参数应该在函数名第一次出现时指定，通常在函数原型中。若己在函数原型中指定默认参数，则函数定义时不能重复给出。
- 默认值可以是常量、全局变量或函数调用，但不能是局部量。
- 默认参数可以用于内联函数。

#### 指针参数

为了避免被调用函数对实参所指对象的修改，可以用关键字 const 约束形参指针的访问特性。

#### 引用参数

- 如果 C++ 函数的形式参数被定义为引用类型，则称为引用参数。引用参数对应的实际参数应该是对象名。函数被调用时，形式参数不需要开辟新的存储空间，形式参数名作为引用（别名）绑定于实际参数标识的对象上。执行函数体时，对形参的操作就是对实参对象操作。直到函数执行结束， 撤销引用绑定。
- 用常数作为实际参数时，C++规定，函数的 const 引用参数允许对应的实际参数为常数或者表达式。调用函数进行参数传递时将产生一个匿名对象保存实参的值。形参标识名作为这个匿名对象的引用，对匿名对象进行操作。匿名对象在被调用函数运行结束后撤销。

#### 函数的返回类型

- 如果函数定义的返回类型为基本数值类型，则执行 return 语句时，首先计算表达式的值，然后把该值赋给 c++ 定义的匿名对象。 匿名对象的类型是函数定义的返回类型。
- 函数被调用之后可以返回一个对象的指针值（地址表达式 ）。返回指针类型值的函数称为指针函数。指针函数的函数原型一般为：**类型 \* 函数名 （ 形式参数表 ）；**
- 注意，指针函数不能返回局部量的指针。返回对象可以是非局部对象或静态对象。
- C++ 函数返回对象引用时，不产生实际返回对象的副本，返回时的匿名对象是实际返回对象的引用。返回引用比返回指针更直接，可读性更好。
- 函数返回引用，使得函数调用本身是对象的引用，就像返回对象的标识别名。所以，返回引用的函数调用可以作为左值。

#### 函数地址

- 函数、应用程序是编译器处理的对象。每个函数的语句序列经过编译之后，生成的都是二进制代码。这些代码要调入内存才能够运行。每条指令、每个函数模块都有一个首地址。
- 一个己经定义的函数，它的名字就是函数的入口地址。
- 编译器调用函数不需要区分地址和名。对于一个己经定义的函数，函数名、函数地址（指针）、函数指针所指对象都是同一样东西，表示函数的入口地址。

#### 函数的类型

- 函数的类型（注意，不是函数的返回值类型）是指函数的接口，包括函数的参数定义和返回类型。
- 一般地，表示函数类型的形式为：**类型 （ 形式参数表 ）**
- C++中，可以用关键字 typedef 定义函数类型名。函数类型名定义的一般形式为：**typedef 类型 函数类型名 （ 形式参数表 ）**

#### 函数指针

要定义指向某一类函数的指针变量，可以用以下两种说明语句：
**类型 （ \* 指针变量名 ） （ 形式参数表 ）**
**函数类型 \* 指针变量名**

#### 内联函数

- 若 inline 不在函数名第一次出现时指定，则编译器把它作为普通函数处理。
- 一般内联函数只适合于 1 ～ 5 行的小程序。在内联函数中，不能含有复杂的流程控制语句。
- 递归函数不能说明为内联函数。

#### 重载函数

- C++ 编译器只根据函数参数表（参数类型和个数）进行重载版本的调用匹配，函数返回值的内容不起作用。
- 另外，要注意重载函数中使用默认参数时可能产生的二义性。

#### 变量存储特性与标识符作用域

- 一个被说明的变量，除名字、类型和值的基本特性外，还有其他特性，包括存储、作用域、可见性和连接等特性。
- 标识符存储特性确定了标识符在内存中的生存时间和连接特性。
- 标识符作用域是指在程序正文中能够引用这个标识符的那部分区域。
- 如果一个标识符在作用域的某部分程序正文区域中能够被直接引用，则称标识符在这个区域中可见。
- c++ 的一个应用程序称为一个项目。一个项目可以由多个文件组成。标识符的连接特性决定标识符能否被工程中的其他文件引用。

#### 自动存储

- 自动存储用关键字 auto 和 register 说明。**只有变量具有自动存储特性**。 这种变量在进入说明的块时生成，在结束块时删除。
- 函数的参数和局部变量都是自动存储的。C++ 把变量默认为自动存储，所以关键字 auto 很少用。
- 关键字 register 说明把变量存放在寄存器中。如今，C++ 的优化编译器能够识别经常使用的变量。

#### 静态存储

- 关键字 extern 和 static 说明静态存储变量和函数标识符。全局说明的标识符默认为 extern。
- 如果这两个关键字用于说明变量，程序在开始执行时就分配和初始化存储空间；
- 如果用于说明函数，表示从程序执行开始就存在这个函数名。
- 尽管标识符被说明为静态时，程序一开始执行就存在，但不等于它们在整个程序中可用。用 static 说明的局部变量只能在定义该变量的函数体中使用。
- 与自动变量不同的是，static 在第一次使用时进行初始化（默认初始化值为 0）。函数退出时，系统保持其存储空间和数值。下次调用这个函数时，static 变量还是上次退出函数时的值。

#### 全局变量和局部变量

具有文件作用域的变量称为全局变量，具有块作用域的变量称为局部变量。全局变量说明时默认初始值为 0 。当局部量与全局量同名时，在块内，全局量被屏蔽。要在块内访问全局量，可以用作用域运算符 “::”

#### 多文件程序结构

- 程序员经常使用两类文件：扩展名为 .h 的头文件和扩展名为 .cpp 源程序文件。
- 一个能够表达特定程序功能的模块由两部分构成：规范说明和实现部分。规范说明描述一个模块与其他模块的接口，一般包括：函数原型、类说明、类型说明、全局量说明、包含指令、宏定义 、注释等。
- 规范说明通常集中在头文件，各模块通过头文件的接口产生引用。实现部分则放在 .cpp 文件中，通常称为实现文件。

#### 条件编译

形式 3：

```c++
#ifndef 标识符
#define 标识符
程序文本
#endif
```

- 若 “标识符” 没有定义，则 “程序文本” 被编译；若 “标识符” 己经定义，则 “程序文本” 被忽略。
- 第 3 种形式的条件编译通常用于多文件结构的头文件中，避免 include 指令嵌入文本导致联编时出现重定义的错误。例如，为了方便起见，头文件会有一些变量说明、函数代码的定义。如果一个 .cpp 文件中己经有了这些定义，则直接包含头文件会产生重定义错误。在头文件中使用条件编译指令，起编译时阻隔作用。
- 声明语句是可以在同一个文件中重复出现的（定义语句不行）。
- 为避免多文件结构的重定义错误，除了在头文件中使用条件编译指令外，还应该尽量做到声明和定义分离，在头文件中只写数据类型、函数原型声明，把变量的定义和函数定义放在 .cpp 文件中，养成良好的程序书写习惯。

#### 多文件程序使用全局变量

- 在所有函数之外定义的全局变量在默认情况下具有静态存储特性。
- 全局变量可以被同一个文件中该变量说明之后的所有函数访问。程序的其他文件也能够访问全局变量，但必须在使用该全局变量的每个文件中用关键字 extern 予以声明。
- 函数原型默认为 extern，即一个文件中只要声明了函数原型，函数定义就可以放在同一个文件或另外的文件中。例如，用 include 指令把函数原型嵌入当前文件之后，程序员就不需去关心函数定义的位置了。
- 如果希望全局变量或函数的作用范围限制在定义它的文件中，可以使用存储说明符 static。

#### 命名空间

- C++ 语言标准头文件没有扩展名。使用标准类库的组件时，需要指定名空间。
- 如果不用 using 声明名空间，则需要在使用时指定组件的名空间。
- 若包含标准名空间没有定义的头文件，则不能省略扩展名。

#### 使用命名空间

using 语句有两种形式：
**using namespace 名空间 ；**
**using 名空间 = 元素 ；**

---

### 第四章 数组

#### 一维数组

- 在计算机中，一个数组在内存中占有一片连续的存储区域，C++ 的数组名就是这块存储空间的地址。数组的每个元素都用下标变量标识。数组要求先定义后使用。
- 一维数组的说明格式为：**类型 标识符 [ 表达式 ]；**
- “[ ]” 是数组类型符，用于说明 “标识符” 的类型。
- 数组说明的作用是在程序运行前分配内存空间。编译程序要确定数组的大小，所以类型符必须己经定义，下标表达式也必须有确定值，不能为变量名，也不能为浮点型表达式。
- 说明一个数组变量后， c++ 数组元素的值是内存的随机状态值。数组可以在定义的同时进行初始化。形式为：以一对花括号给出常量值表，系统按下标顺序（ 存储顺序 ）对数组元素进行初始化。给定常数的个数不能超过数组定义的长度。如果给定常数的个数不足，则系统对其余元素初始化为 0 值。
- 只有定义静态数组， C++ 才会自动把各元素值初始化为 0 。
- C++ 不会对数组元素的下标表达式作界限检查，操作出界时可能会引起意想不到的错误。
- a+i 和 p++ 计算的偏移单位是一个整型数据的长度。(int a[10]； int \*p=a；)

#### 指针数组

- 一个数组的元素可以是各种己定义的数据类型。当数组元素的类型为指针类型时，称为指针数组。使用指针数组便于对一组相关对象的地址进行管理。
- 指针数组说明形式为： **类型 \* 标识符 [ 表达式 ]；**

#### 指向数组的指针数组

- 当指针数组元素存放数组地址时，可以通过这个指针数组访问这些数组的元素。
- ![](assets/2023-04-20-22-05-53.png)
- （注：pf[0]可以指向 double 基本类型，也可以指向 double[]数组）

#### 指向函数的指针数组

- **int()**表示返回整型值的无参函数类型, 旨向该类型函数的指针类型是：**int (\*)()**； 指向该类型函数的指针数组类型是：**int(\*[])()**；定义一个上述类型的指针数组如：**int (\*pfun[3])()**
- 可以用关键字 typedef 定义函数类型， 然后说明指针数组：**typedef int fType();** **fType \*pfun[3];**
- (不存在指向函数数组的指针吗？)

#### 二维数组

- 二维数组的说明格式为： **类型 数组名 [ 表达式 1 ] [ 表达式 2 ]；**
  int am[2][3] = {{1,2,3},{3,4,5}};
  int am[2][3] = {1,2,3,4,5,6};
- 以上两种初始化方式是等价的。
- 利用初始化值表，可以省略高维数组的最高维长度说明，例如：int ad[][3] = {1，2，3，4，5，6}；
- 对于二维数组，不带下标的数组名是一个逻辑上的二级指针，所指对象是行向量，偏移量是一行元素的存储长度。带一个下标的数组名是一级指针，偏移量是一个元素的长度，它所指的对象是数组元素。
- 如果定义一个二维数组和二级指针变量 int a[3][4]，\*\*pp; 不可以用 pp=a; 因为 pp 的定义可以解读为： int *(*pp); 即指针 pp 的关联类型是 int\*。 而数组 a 的定义可以解读为： int (a[3])[4]; a 是关联类型为 int[4] 的一维数组。
- pp + i 的偏移量是 pp + sizeof(int*) * i; 而 a + i 偏移量是 a + sizeof(int[4]) \* i;
- 可见，二级指针变量与二维数组名是有区别的。由此可知，只有定义一个**指向一维数组的指针**，才可以操作逻辑上为二级指针的二维数组名。（二级指针中第一级指向数组或基本类型没有区别，**但第二级是有区别的**，若指向数组的话一级指针的偏移量会是数组的大小，若指向基本元素偏移量只是基本元素的大小）
- ![](assets/2023-04-20-22-04-55.png)
- （注意 1：int *a[3] 和 int (*a)[3] 是不同的，前者是存储 int \*数据的一维数组，而后者是一个指向一维数组的指针）
- （注意 2：int a[3] 和 int (\*a)[3]的区别，前者 a 代表数组的首地址，后者 a 代表一个存储啊 a[3]首地址的变量）

#### 数组名作为函数参数

当数组名作为函数参数时，C++ 进行传地址处理。调用函数时，形参数组名接收实参数组的地址，函数通过形参指针对实参数组间接访问。

```c++
void f(int x[])
{
    printf("%d\n", sizeof(x)); // 8字节指针
    // 形式参数 x 虽然说明为：int x[], 但它不是一个真正的数组，而是一个指针类型的
    // 临时变量，用于存放实参数组 a 的地址。所以将一维数组形参 x 说明为整型指针是等价的，
    // 即int *x，可见，在函数 f 内是允许修改指针 x。
    // 例如，可以在函数体内用 x 指针移动方式访问数组。
}
int main()
{
    int a[] = {1, 2, 3};
    printf("%d\n", sizeof(a)); // 3*4=12字节数组
    // 实参 a 是编译时建立的数组，类型为：int[3]
    f(a);
}
```

![](assets/2023-04-20-22-03-54.png)

#### 线性同余法生成随机数

- 随机数序列中的每个数 $r_k$ 可以按下列公式由它的前一个数计算出来：
  $r_k = (\text{multiplier} × r_{k-1} + \text{increment}) ％ \text{modulus}$
- 例如， 如果有：$r_k =  25173 × r_{k-1} + 13849 ）％\  65536$, 可以产生 65 536 个各不相同的整型随机数。

#### 动态存储

- C++ 使用 new 和 delete 操作符动态分配存储空间和动态释放己分配的存储空间。new 和 delete 的一般语法形式为：
  **指针变量 = new 类型**
  **delete 指针变量**
- new 操作符按照指定类型的长度分配存储空间，并返回所分配空间的首地址。“类型” 可以是任意类型，例如，基本数据类型，数组类型、结构类型、类类型，包括函数指针类型等，但不允许是函数类型。
- 如果需要申请动态数组，new 操作的 “类型” 使用数组类型，释放存储空间使用 delete[] 操作。
- delete 运算释放了指针变量所指的空间，并没有删除指针变量本身的存储单元和清除指针变量原来的值。一个好的编程习惯是，在 delete 操作之后，对指针变量赋 NULL。
- 由 new 分配的堆空间与普通变量不同，它没有名字，只能通过指针对堆空间进行间址方式访问。
- new 运算符申请基本类型空间时，可以用 “()” 对存储区赋初始值。如 p = new int(89);
- 动态分配数组: pa = new int[len];

#### 字符数组与字符串

- 为了表示一个字符串的结束位置，可以用 '\0' 作为标记，在程序处理中，检测到 '\0'，就认为一个字符串结束了。
- ![](assets/2023-04-20-21-37-08.png)
- C++ 对串常量自动添加结束标志 '\0'。
- 用字符指针管理串： char \*string = "Student"；对字符指针可以用串常量初始化，实际上系统完成两步操作：首先申请堆空间，然后填入串值。（str3 是常指针，而 string 是可以作为左值的指针变量）
- 指针数组存储字符串：char \*name[5] = { "Chen Ming" ， "Li Ying" ， "Zhang Xiao jian" ， "Huang Qiang" ， "He Yong fei" }；
- ![](assets/2023-04-20-21-50-51.png)
- ![](assets/2023-04-20-21-50-03.png)

#### 字符串处理函数

![](assets/2023-04-20-21-49-06.png)

#### string 类

- C++ 标准库（STL，standard Template Library）中定义了一个 string 类，封装了字符串的基本特性和对字符串各种典型操作，并重载一批运算符，使得字符串操作变得直接、简洁。类的各种操作都设置了下标范围和长度检查，提高了操作的安全性。
- ![](assets/2023-04-20-21-53-45.png)
- ![](assets/2023-04-20-21-54-22.png)

---

### 第五章 集合与结构

#### 位运算

- ![](assets/2023-04-20-21-57-50.png)
- 变量 a 用 b 进行两次异或运算，不会改变原来的值。（a 和 b 异或的结果，再和 a 异或得到 b，和 b 异或得到 a）
- ![](assets/2023-04-20-22-24-37.png)
- ![](assets/2023-04-20-21-59-45.png)
- 位运算要求的操作数类型是整型，实际上，C++ 按位操作数据，不会用类型解释存储单元中的数据值。若要交换浮点型变量的数据，可以用指针方式分段处理数据。这个思路同样适用于快速处理大批量数据。
- ![](assets/2023-04-20-22-02-24.png)

#### 集合

![](assets/2023-04-20-22-28-20.png)

#### 结构

- 说明结构变量的同时可以进行初始化，例如：
  Employee worker={"Wang Li"，991083456，200.5，"Guang_Zhou"，"87111111"}；
- 访问结构变量成员使用圆点运算符：**结构变量名.成员**
- 如果用指针访问结构，所指对象包含了结构的数据成员，则访问形式为：**\*(指针).成员** 或 **指针->成员**
- 假如 pp 是结构类型指针，若执行 pp++，则偏移量是一个结构的长度 0。
- 类型相同的结构变量可以使用赋值运算。所谓 “ 类型相同的变量 ”，是指用同一个类型标识
  符说明的变量。

---
